<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Chapter 17 Group Replication</title>
<link rel="stylesheet" href="mvl.css" type="text/css" />
<meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2" />
<link rel="start" href="index.html" title="{book-title}" />
<link rel="up" href="" title="" />
<link rel="prev" href="replication.html" title="Chapter 16 Replication" />
<link rel="next" href="mysql-shell-userguide.html" title="Chapter 18 MySQL Shell" />
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr>
<th colspan="3" align="center">Chapter 17 Group Replication</th>
</tr>
<tr>
<td width="20%" align="left"><a accesskey="p" href="replication.html">Prev</a> </td>
<th width="60%" align="center"></th>
<td width="20%" align="right"> <a accesskey="n" href="mysql-shell-userguide.html">Next</a></td>
</tr>
</table>
<hr>
</div>
<div class="chapter">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a name="group-replication"></a>Chapter 17 Group Replication</h1>

</div>

</div>

</div>
<div class="toc">
<p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-background">17.1 Group Replication Background</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-replication-technologies">17.1.1 Replication Technologies</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-use-cases">17.1.2 Group Replication Use Cases</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-details">17.1.3 Group Replication Details</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-getting-started">17.2 Getting Started</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-single-primary-mode">17.2.1 Deploying Group Replication in Single-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-deploying-locally">17.2.2 Deploying Group Replication Locally</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-monitoring">17.3 Monitoring Group Replication</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-server-states">17.3.1 Group Replication Server States</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-members">17.3.2 The replication_group_members Table</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-member-stats">17.3.3 The replication_group_member_stats Table</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-operations">17.4 Group Replication Operations</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-multi-primary-or-single-primary-mode">17.4.1 Deploying in Multi-Primary or Single-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-tuning-recovery">17.4.2 Tuning Recovery</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-network-partitioning">17.4.3 Network Partitioning</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-enterprise-backup">17.4.4 Using MySQL Enterprise Backup with Group Replication</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-security">17.5 Group Replication Security</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-ip-address-whitelisting">17.5.1 Group Replication IP Address Whitelisting</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-secure-socket-layer-support-ssl">17.5.2 Group Replication Secure Socket Layer (SSL) Support</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-virtual-private-networks-vpn">17.5.3 Group Replication and Virtual Private Networks (VPNs)</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-options">17.6 Group Replication System Variables</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-requirements-and-limitations">17.7 Requirements and Limitations</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-requirements">17.7.1 Group Replication Requirements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-limitations">17.7.2 Group Replication Limitations</a></span></dt></dl></dd><dt><span class="section"><a href="group-replication.html#group-replication-frequently-asked-questions">17.8 Frequently Asked Questions</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-technical-details">17.9 Group Replication Technical Details</a></span></dt><dd><dl><dt><span class="section"><a href="group-replication.html#group-replication-plugin-architecture">17.9.1 Group Replication Plugin Architecture</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-the-group">17.9.2 The Group</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-data-manipulation-statements">17.9.3 Data Manipulation Statements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-data-definition-statements">17.9.4 Data Definition Statements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery">17.9.5 Distributed Recovery</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-observability">17.9.6 Observability</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-performance">17.9.7 Group Replication Performance</a></span></dt></dl></dd></dl>
</div>
<a class="indexterm" name="idm140572003643600"></a><a class="indexterm" name="idm140572003642528"></a><p>
    This chapter explains MySQL Group Replication and how to install,
    configure and monitor groups. MySQL Group Replication is a MySQL
    Server plugin that enables you to create elastic, highly-available,
    fault-tolerant replication topologies.
  </p><p>
    Groups can operate in a single-primary mode with automatic primary
    election, where only one server accepts updates at a time.
    Alternatively, for more advanced users, groups can be deployed in
    multi-primary mode, where all servers can accept updates, even if
    they are issued concurrently.
  </p><p>
    There is a built-in group membership service that keeps the view of
    the group consistent and available for all servers at any given
    point in time. Servers can leave and join the group and the view is
    updated accordingly. Sometimes servers can leave the group
    unexpectedly, in which case the failure detection mechanism detects
    this and notifies the group that the view has changed. This is all
    automatic.
  </p><p>
    The chapter is structured as follows:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-background" title="17.1 Group Replication Background">Section 17.1, “Group Replication Background”</a> provides an
        introduction to groups and how Group Replication works.
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-getting-started" title="17.2 Getting Started">Section 17.2, “Getting Started”</a> explains how
        to configure multiple MySQL Server instances to create a group.
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-monitoring" title="17.3 Monitoring Group Replication">Section 17.3, “Monitoring Group Replication”</a> explains how to
        monitor a group.
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-operations" title="17.4 Group Replication Operations">Section 17.4, “Group Replication Operations”</a> explains how to
        work with a group.
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-security" title="17.5 Group Replication Security">Section 17.5, “Group Replication Security”</a> explains how to
        secure a group.
      </p></li><li class="listitem"><p>
        <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/group-replication-upgrade.html" target="_top">Upgrading Group Replication</a> explains how to
        upgrade a group.
      </p></li><li class="listitem"><p>
        <a class="xref" href="group-replication.html#group-replication-technical-details" title="17.9 Group Replication Technical Details">Section 17.9, “Group Replication Technical Details”</a> provides
        in-depth information about how Group Replication works.
</p></li></ul>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="group-replication-background"></a>17.1 Group Replication Background</h2>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-replication-technologies">17.1.1 Replication Technologies</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-use-cases">17.1.2 Group Replication Use Cases</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-details">17.1.3 Group Replication Details</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572003625152"></a><p>
    This section provides background information on MySQL Group
    Replication.

    
  </p><p>
    The most common way to create a fault-tolerant system is to resort
    to making components redundant, in other words the component can be
    removed and the system should continue to operate as expected. This
    creates a set of challenges that raise complexity of such systems to
    a whole different level. Specifically, replicated databases have to
    deal with the fact that they require maintenance and administration
    of several servers instead of just one. Moreover, as servers are
    cooperating together to create the group several other classic
    distributed systems problems have to be dealt with, such as network
    partitioning or split brain scenarios.
  </p><p>
    Therefore, the ultimate challenge is to fuse the logic of the
    database and data replication with the logic of having several
    servers coordinated in a consistent and simple way. In other words,
    to have multiple servers agreeing on the state of the system and the
    data on each and every change that the system goes through. This can
    be summarized as having servers reaching agreement on each database
    state transition, so that they all progress as one single database
    or alternatively that they eventually converge to the same state.
    Meaning that they need to operate as a (distributed) state machine.
  </p><p>
    MySQL Group Replication provides distributed state machine
    replication with strong coordination between servers. Servers
    coordinate themselves automatically when they are part of the same
    group. The group can operate in a single-primary mode with automatic
    primary election, where only one server accepts updates at a time.
    Alternatively, for more advanced users the group can be deployed in
    multi-primary mode, where all servers can accept updates, even if
    they are issued concurrently. This power comes at the expense of
    applications having to work around the limitations imposed by such
    deployments.
  </p><p>
    There is a built-in group membership service that keeps the view of
    the group consistent and available for all servers at any given
    point in time. Servers can leave and join the group and the view is
    updated accordingly. Sometimes servers can leave the group
    unexpectedly, in which case the failure detection mechanism detects
    this and notifies the group that the view has changed. This is all
    automatic.
  </p><p>
    For a transaction to commit, the majority of the group have to agree
    on the order of a given transaction in the global sequence of
    transactions. Deciding to commit or abort a transaction is done by
    each server individually, but all servers make the same decision. If
    there is a network partition, resulting in a split where members are
    unable to reach agreement, then the system does not progress until
    this issue is resolved. Hence there is also a built-in, automatic,
    split-brain protection mechanism.
  </p><p>
    All of this is powered by the provided Group Communication System
    (GCS) protocols. These provide a failure detection mechanism, a
    group membership service, and safe and completely ordered message
    delivery. All these properties are key to creating a system which
    ensures that data is consistently replicated across the group of
    servers. At the very core of this technology lies an implementation
    of the Paxos algorithm. It acts as the group communication engine.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-replication-technologies"></a>17.1.1 Replication Technologies</h3>

</div>

</div>

</div>

<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-primary-secondary-replication">17.1.1.1 Primary-Secondary Replication</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-summary">17.1.1.2 Group Replication</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572003615360"></a><a class="indexterm" name="idm140572003613856"></a><p>
      Before getting into the details of MySQL Group Replication, this
      section introduces some background concepts and an overview of how
      things work. This provides some context to help understand what is
      required for Group Replication and what the differences are
      between classic asynchronous MySQL Replication and Group
      Replication.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-primary-secondary-replication"></a>17.1.1.1 Primary-Secondary Replication</h4>
</div>
</div>
</div>
<a class="indexterm" name="idm140572003610768"></a><a class="indexterm" name="idm140572003609264"></a><p>
        Traditional MySQL Replication provides a simple
        Primary-Secondary approach to replication. There is a primary
        (master) and there is one or more secondaries (slaves). The
        primary executes transactions, commits them and then they are
        later (thus asynchronously) sent to the secondaries to be either
        re-executed (in statement-based replication) or applied (in
        row-based replication). It is a shared-nothing system, where all
        servers have a full copy of the data by default.
</p>
<div class="figure">
<a name="idm140572003606816"></a><p class="title"><b>Figure 17.1 MySQL Asynchronous Replication</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/async-replication-diagram.png" width="911" height="315" alt="A transaction received by the master is executed, written to the binary log, then committed, and a response is sent to the client application. The record from the binary log is sent to the relay logs on Slave 1 and Slave 2 before the commit takes place on the master. On each of the slaves, the transaction is applied, written to the slave's binary log, and committed. The commit on the master and the commits on the slaves are all independent and asynchronous.">
</div>

</div>

</div>
<br class="figure-break"><p>
        There is also semisynchronous replication, which adds one
        synchronization step to the protocol. This means that the
        Primary waits, at commit time, for the secondary to acknowledge
        that it has <span class="emphasis"><em>received</em></span> the transaction. Only
        then does the Primary resume the commit operation.
</p>
<div class="figure">
<a name="idm140572003598528"></a><p class="title"><b>Figure 17.2 MySQL Semisynchronous Replication</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/semisync-replication-diagram.png" width="911" height="316" alt="A transaction received by the master is executed and written to the binary log. The record from the binary log is sent to the relay logs on Slave 1 and Slave 2. The master then waits for an acknowledgement from the slaves. When both of the slaves have returned the acknowledgement, the master commits the transaction, and a response is sent to the client application. After each slave has returned its acknowlegement, it applies the transaction, writes it to the binary log, and commits it. The commit on the master depends on the acknowledgement from the slaves, but the commits on the slaves are independent from each other and from the commit on the master.">
</div>

</div>

</div>
<br class="figure-break"><p>
        In the two pictures above, you can see a diagram of the classic
        asynchronous MySQL Replication protocol (and its semisynchronous
        variant as well). Diagonal arrows represent messages exchanged
        between servers or messages exchanged between servers and the
        client application.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-summary"></a>17.1.1.2 Group Replication</h4>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003589104"></a><p>
        Group Replication is a technique that can be used to implement
        fault-tolerant systems. The replication group is a set of
        servers that each have their own entire copy of the data (a
        shared-nothing replication scheme), and interact with each other
        through message passing. The communication layer provides a set
        of guarantees such as atomic message and total order message
        delivery. These are very powerful properties that translate into
        very useful abstractions that one can resort to build more
        advanced database replication solutions.
      </p><p>
        MySQL Group Replication builds on top of such properties and
        abstractions and implements a multi-master update everywhere
        replication protocol. A replication group is formed by multiple
        servers and each server in the group may execute transactions
        independently at any time. However, all read-write transactions
        commit only after they have been approved by the group. In other
        words, for any read-write transaction the group needs to decide
        whether it commits or not, so the commit operation is not a
        unilateral decision from the originating server. Read-only
        transactions need no coordination within the group and commit
        immediately.
      </p><p>
        When a read-write transaction is ready to commit at the
        originating server, the server atomically broadcasts the write
        values (the rows that were changed) and the corresponding write
        set (the unique identifiers of the rows that were updated).
        Because the transaction is sent through an atomic broadcast,
        either all servers in the group receive the transaction or none
        do. If they receive it, then they all receive it in the same
        order with respect to other transactions that were sent before.
        All servers therefore receive the same set of transactions in
        the same order, and a global total order is established for the
        transactions.
      </p><p>
        However, there may be conflicts between transactions that
        execute concurrently on different servers. Such conflicts are
        detected by inspecting and comparing the write sets of two
        different and concurrent transactions, in a process called
        <span class="emphasis"><em>certification</em></span>. During certification,
        conflict detection is carried out at row level: if two
        concurrent transactions, that executed on different servers,
        update the same row, then there is a conflict. The conflict
        resolution procedure states that the transaction that was
        ordered first commits on all servers, and the transaction
        ordered second aborts, and is therefore rolled back on the
        originating server and dropped by the other servers in the
        group. For example, if t1 and t2 execute concurrently at
        different sites, both changing the same row, and t2 is ordered
        before t1, then t2 wins the conflict and t1 is rolled back. This
        is in fact a distributed first commit wins rule. Note that if
        two transactions are bound to conflict more often than not, then
        it is a good practice to start them on the same server, where
        they have a chance to synchronize on the local lock manager
        instead of being rolled back as a result of certification.
      </p><p>
        For applying and externalizing the certified transactions, Group
        Replication permits servers to deviate from the agreed order of
        the transactions if this does not break consistency and
        validity. Group Replication is an eventual consistency system,
        meaning that as soon as the incoming traffic slows down or
        stops, all group members have the same data content. While
        traffic is flowing, transactions can be externalized in a
        slightly different order, or externalized on some members before
        the others. For example, in multi-primary mode, a local
        transaction might be externalized immediately following
        certification, although a remote transaction that is earlier in
        the global order has not yet been applied. This is permitted
        when the certification process has established that there is no
        conflict between the transactions. In single-primary mode, on
        the primary server, there is a small chance that concurrent,
        non-conflicting local transactions might be committed and
        externalized in a different order from the global order agreed
        by Group Replication. On the secondaries, which do not accept
        writes from clients, transactions are always committed and
        externalized in the agreed order.
      </p><p>
        The following figure depicts the MySQL Group Replication
        protocol and by comparing it to MySQL Replication (or even MySQL
        semisynchronous replication) you can see some differences. Note
        that some underlying consensus and Paxos related messages are
        missing from this picture for the sake of clarity.
</p>
<div class="figure">
<a name="idm140572003577680"></a><p class="title"><b>Figure 17.3 MySQL Group Replication Protocol</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-replication-diagram.png" width="898" height="375" alt="A transaction received by Master 1 is executed. Master 1 then sends a message to the replication group, consisting of itself, Master 2, and Master 3. When all three members have reached consensus, they certify the transaction. Master 1 then writes the transaction to its binary log, commits it, and sends a response to the client application. Masters 2 and 3 write the transaction to their relay logs, then apply it, write it to the binary log, and commit it.">
</div>

</div>

</div>
<br class="figure-break">
</div>

</div>

<div class="section">

<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-use-cases"></a>17.1.2 Group Replication Use Cases</h3>

</div>

</div>

</div>

<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-examples-of-use-case-scenarios">17.1.2.1 Examples of Use Case Scenarios</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572003569120"></a><p>
      Group Replication enables you to create fault-tolerant systems
      with redundancy by replicating the system state to a set of
      servers. Even if some of the servers subsequently fail, as long it
      is not all or a majority, the system is still available. Depending
      on the number of servers which fail the group might have degraded
      performance or scalability, but it is still available. Server
      failures are isolated and independent. They are tracked by a group
      membership service which relies on a distributed failure detector
      that is able to signal when any servers leave the group, either
      voluntarily or due to an unexpected halt. There is a distributed
      recovery procedure to ensure that when servers join the group they
      are brought up to date automatically. There is no need for server
      fail-over, and the multi-master update everywhere nature ensures
      that even updates are not blocked in the event of a single server
      failure. To summarize, MySQL Group Replication guarantees that the
      database service is continuously available.
    </p><p>
      It is important to understand that although the database service
      is available, in the event of a server crash, those clients
      connected to it must be redirected, or failed over, to a different
      server. This is not something Group Replication attempts to
      resolve. A connector, load balancer, router, or some form of
      middleware are more suitable to deal with this issue. For example
      see <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router 8.0</a>.

      
    </p><p>
      To summarize, MySQL Group Replication provides a highly available,
      highly elastic, dependable MySQL service.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-examples-of-use-case-scenarios"></a>17.1.2.1 Examples of Use Case Scenarios</h4>
</div>
</div>
</div>
<a class="indexterm" name="idm140572003561936"></a><p>
        The following examples are typical use cases for Group
        Replication.
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>Elastic Replication</em></span> - Environments that
            require a very fluid replication infrastructure, where the
            number of servers has to grow or shrink dynamically and with
            as few side-effects as possible. For instance, database
            services for the cloud.
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>Highly Available Shards</em></span> - Sharding is a
            popular approach to achieve write scale-out. Use MySQL Group
            Replication to implement highly available shards, where each
            shard maps to a replication group.
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>Alternative to Master-Slave replication</em></span>
            - In certain situations, using a single master server makes
            it a single point of contention. Writing to an entire group
            may prove more scalable under certain circumstances.

            
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>Autonomic Systems</em></span> - Additionally, you
            can deploy MySQL Group Replication purely for the automation
            that is built into the replication protocol (described
            already in this and previous chapters).

            
</p></li></ul>
</div>

</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-details"></a>17.1.3 Group Replication Details</h3>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-group-membership">17.1.3.1 Group Membership</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-failure-detection">17.1.3.2 Failure Detection</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-fault-tolerance">17.1.3.3 Fault-tolerance</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572003550832"></a><p>
      This section presents details about some of the services that
      Group Replication builds on.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-group-membership"></a>17.1.3.1 Group Membership</h4>
</div>
</div>
</div>
<a class="indexterm" name="idm140572003547600"></a><a class="indexterm" name="idm140572003546112"></a><p>
        In MySQL Group Replication, a set of servers forms a replication
        group. A group has a name, which takes the form of a UUID. The
        group is dynamic and servers can leave (either voluntarily or
        involuntarily) and join it at any time. The group adjusts itself
        whenever servers join or leave.
      </p><p>
        If a server joins the group, it automatically brings itself up
        to date by fetching the missing state from an existing server.
        If a server leaves the group, for instance it was taken down for
        maintenance, the remaining servers notice that it has left and
        reconfigure the group automatically.
      </p><p>
        Group Replication has a group membership service that defines
        which servers are online and participating in the group. The
        list of online servers is referred to as a
        <span class="emphasis"><em>view</em></span>. Every server in the group has a
        consistent view of which servers are the members participating
        actively in the group at a given moment in time.
      </p><p>
        Group members must agree not only on transaction commits, but
        also on which is the current view. If existing members agree
        that a new server should become part of the group, the group is
        reconfigured to integrate that server in it, which triggers a
        view change. If a server leaves the group, either voluntarily or
        not, the group dynamically rearranges its configuration and a
        view change is triggered.
      </p><p>
        In the case where a member leaves the group voluntarily, it
        first initiates a dynamic group reconfiguration, during which
        all members have to agree on a new view without the leaving
        server. However, if a member leaves the group involuntarily, for
        example because it has stopped unexpectedly or the network
        connection is down, it cannot initiate the reconfiguration. In
        this situation, Group Replication's failure detection mechanism
        recognizes after a short period of time that the member has
        left, and a reconfiguration of the group without the failed
        member is proposed. As with a member that leaves voluntarily,
        the reconfiguration requires agreement from the majority of
        servers in the group. However, if the group is not able to reach
        agreement, for example because it partitioned in such a way that
        there is no majority of servers online, the system is not able
        to dynamically change the configuration, and blocks to prevent a
        split-brain situation. This situation requires intervention from
        an administrator.
      </p><p>
        It is possible for a member to go offline for a short time, then
        attempt to rejoin the group again before the failure detection
        mechanism has detected its failure, and before the group has
        been reconfigured to remove the member. In this situation, the
        rejoining member forgets its previous state, but if other
        members send it messages that are intended for its pre-crash
        state, this can cause issues including possible data
        inconsistency. If a member in this situation participates in
        XCom's consensus protocol, it could potentially cause XCom to
        deliver different values for the same consensus round, by making
        a different decision before and after failure.
      </p><p>
        To counter this possibility, from MySQL 5.7.22, servers are
        given a unique identifier when they join a group. This enables
        Group Replication to be aware of the situation where a new
        incarnation of the same server (with the same address but a new
        identifier) is trying to join the group while its old
        incarnation is still listed as a member. The new incarnation is
        blocked from joining the group until the old incarnation can be
        removed by a reconfiguration. If Group Replication is stopped
        and restarted on the server, the member becomes a new
        incarnation and cannot rejoin until the suspicion times out.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-failure-detection"></a>17.1.3.2 Failure Detection</h4>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003535984"></a><a class="indexterm" name="idm140572003534496"></a><p>
        Group Replication includes a failure detection mechanism that is
        able to find and report which servers are silent and as such
        assumed to be dead. At a high level, the failure detector is a
        distributed service that provides information about which
        servers may be dead (suspicions). Suspicions are triggered when
        servers go mute. When server A does not receive messages from
        server B during a given period, a timeout occurs and a suspicion
        is raised. Later if the group agrees that the suspicions are
        probably true, then the group decides that a given server has
        indeed failed. This means that the remaining members in the
        group take a coordinated decision to exclude a given member.
      </p><p>
        Suspicions are triggered when servers go mute. When server A
        does not receive messages from server B during a given period, a
        timeout occurs and a suspicion is raised.
      </p><p>
        If a server gets isolated from the rest of the group, then it
        suspects that all others have failed. Being unable to secure
        agreement with the group (as it cannot secure a quorum), its
        suspicion does not have consequences. When a server is isolated
        from the group in this way, it is unable to execute any local
        transactions.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-fault-tolerance"></a>17.1.3.3 Fault-tolerance</h4>

</div>

</div>

</div>
<p>
        MySQL Group Replication builds on an implementation of the Paxos
        distributed algorithm to provide distributed coordination
        between servers. As such, it requires a majority of servers to
        be active to reach quorum and thus make a decision. This has
        direct impact on the number of failures the system can tolerate
        without compromising itself and its overall functionality. The
        number of servers (n) needed to tolerate <code class="literal">f</code>
        failures is then <code class="literal">n = 2 x f + 1</code>.
      </p><p>
        In practice this means that to tolerate one failure the group
        must have three servers in it. As such if one server fails,
        there are still two servers to form a majority (two out of
        three) and allow the system to continue to make decisions
        automatically and progress. However, if a second server fails
        <span class="emphasis"><em>involuntarily</em></span>, then the group (with one
        server left) blocks, because there is no majority to reach a
        decision.
      </p><p>
        The following is a small table illustrating the formula above.
</p>
<div class="informaltable">
<table summary="Relationship between replication group size, the number of servers that constitute a majority, and the number of instant failures that can be tolerated."><col width="0.23%"><col width="0.18%"><col width="0.59%"><thead><tr>
            <th scope="col"><p>
                Group Size
              </p></th>
            <th scope="col"><p>
                Majority
              </p></th>
            <th scope="col"><p>
                Instant Failures Tolerated
              </p></th>
          </tr></thead><tbody><tr>
            <td scope="row"><p>
                1
              </p></td>
            <td><p>
                1
              </p></td>
            <td><p>
                0
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                2
              </p></td>
            <td><p>
                2
              </p></td>
            <td><p>
                0
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                3
              </p></td>
            <td><p>
                2
              </p></td>
            <td><p>
                1
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                4
              </p></td>
            <td><p>
                3
              </p></td>
            <td><p>
                1
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                5
              </p></td>
            <td><p>
                3
              </p></td>
            <td><p>
                2
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                6
              </p></td>
            <td><p>
                4
              </p></td>
            <td><p>
                2
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                7
              </p></td>
            <td><p>
                4
              </p></td>
            <td><p>
                3
              </p></td>
</tr></tbody></table>
</div>
<p>
        The next Chapter covers technical aspects of Group Replication.

        
</p>
</div>

</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="group-replication-getting-started"></a>17.2 Getting Started</h2>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-single-primary-mode">17.2.1 Deploying Group Replication in Single-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-deploying-locally">17.2.2 Deploying Group Replication Locally</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572003487168"></a><p>
    MySQL Group Replication is provided as a plugin to MySQL server, and
    each server in a group requires configuration and installation of
    the plugin. This section provides a detailed tutorial with the steps
    required to create a replication group with at least three members.
</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Tip
</div>
<p>
      An alternative way to deploy multiple instances of MySQL is by
      using InnoDB cluster, which uses Group Replication and wraps it
      in a programmatic environment that enables you to easily work with
      groups of MySQL server instances in the
      <a class="ulink" href="https://dev.mysql.com/doc/mysql-shell/8.0/en/" target="_top">MySQL Shell 8.0 (part of MySQL 8.0)</a>. In addition, InnoDB cluster
      interfaces seamlessly with MySQL Router and simplifies deploying MySQL
      with high availability. See
      <a class="xref" href="mysql-innodb-cluster-userguide.html" title="Chapter 20 InnoDB Cluster">Chapter 20, <i>InnoDB Cluster</i></a>.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-deploying-in-single-primary-mode"></a>17.2.1 Deploying Group Replication in Single-Primary Mode</h3>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-getting-started-deploying-instances">17.2.1.1 Deploying Instances for Group Replication</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-configuring-instances">17.2.1.2 Configuring an Instance for Group Replication</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-user-credentials">17.2.1.3 User Credentials</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-launching">17.2.1.4 Launching Group Replication</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-bootstrap">17.2.1.5 Bootstrapping the Group</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-adding-instances">17.2.1.6 Adding Instances to the Group</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572003481136"></a><p>
      Each of the MySQL server instances in a group can run on an
      independent physical host machine, which is the recommended way to
      deploy Group Replication. This section explains how to create a
      replication group with three MySQL Server instances, each running
      on a different host machine. See
      <a class="xref" href="group-replication.html#group-replication-deploying-locally" title="17.2.2 Deploying Group Replication Locally">Section 17.2.2, “Deploying Group Replication Locally”</a> for
      information about deploying multiple MySQL server instances
      running Group Replication on the same host machine, for example
      for testing purposes.
</p>
<div class="figure">
<a name="idm140572003477824"></a><p class="title"><b>Figure 17.4 Group Architecture</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-3-server-group.png" width="312" height="332" alt="Three server instances, S1, S2, and S3, are deployed as an interconnected group, and clients communicate with each of the server instances.">
</div>

</div>

</div>
<br class="figure-break"><p>
      This tutorial explains how to get and deploy MySQL Server with the
      Group Replication plugin, how to configure each server instance
      before creating a group, and how to use Performance Schema
      monitoring to verify that everything is working correctly.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-getting-started-deploying-instances"></a>17.2.1.1 Deploying Instances for Group Replication</h4>
</div>
</div>
</div>
<a class="indexterm" name="idm140572003469200"></a><p>
        The first step is to deploy at least three instances of MySQL
        Server, this procedure demonstrates using multiple hosts for the
        instances, named s1, s2 and s3. It is assumed that MySQL Server
        was installed on each of the hosts, see
        <a class="xref" href="installing.html" title="Chapter 2 Installing and Upgrading MySQL">Chapter 2, <i>Installing and Upgrading MySQL</i></a>. Group Replication is a built-in
        MySQL plugin provided with MySQL Server 5.7.17 and later. For
        more background information on MySQL plugins, see
        <a class="xref" href="server-administration.html#server-plugins" title="5.5 MySQL Server Plugins">Section 5.5, “MySQL Server Plugins”</a>.
      </p><p>
        In this example, three instances are used for the group, which
        is the minimum number of instances to create a group. Adding
        more instances increases the fault tolerance of the group. For
        example if the group consists of three members, in event of
        failure of one instance the group can continue. But in the event
        of another failure the group can no longer continue processing
        write transactions. By adding more instances, the number of
        servers which can fail while the group continues to process
        transactions also increases. The maximum number of instances
        which can be used in a group is nine. For more information see
        <a class="xref" href="group-replication.html#group-replication-failure-detection" title="17.1.3.2 Failure Detection">Section 17.1.3.2, “Failure Detection”</a>.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-configuring-instances"></a>17.2.1.2 Configuring an Instance for Group Replication</h4>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003462080"></a><p>
        This section explains the configuration settings required for
        MySQL Server instances that you want to use for Group
        Replication. For background information, see
        <a class="xref" href="group-replication.html#group-replication-requirements-and-limitations" title="17.7 Requirements and Limitations">Section 17.7, “Requirements and Limitations”</a>.
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-storage-engines" title="Storage Engines">Storage Engines</a></p></li><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-configure-replication-framework" title="Replication Framework">Replication Framework</a></p></li><li class="listitem"><p><a class="xref" href="group-replication.html#group-replication-configure-plugin" title="Group Replication Settings">Group Replication Settings</a></p></li></ul>
</div>

<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h5 class="title"><a name="group-replication-storage-engines"></a>Storage Engines</h5>

</div>

</div>

</div>
<p>
          For Group Replication, data must be stored in the InnoDB
          transactional storage engine (for details of why, see
          <a class="xref" href="group-replication.html#group-replication-requirements" title="17.7.1 Group Replication Requirements">Section 17.7.1, “Group Replication Requirements”</a>). The use of
          other storage engines, including the temporary
          <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3 The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> storage engine, might
          cause errors in Group Replication. Set the
          <a class="link" href="server-administration.html#sysvar_disabled_storage_engines"><code class="literal">disabled_storage_engines</code></a>
          system variable as follows to prevent their use:
        </p><pre data-lang="ini" class="programlisting">
disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"
</pre><p>
          Note that with the <a class="link" href="storage-engines.html#myisam-storage-engine" title="15.2 The MyISAM Storage Engine"><code class="literal">MyISAM</code></a> storage
          engine disabled, when you are upgrading a MySQL instance to a
          release where <a class="link" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a> is still used
          (before MySQL 8.0.16), <a class="link" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a> might
          fail with an error. To handle this, you can re-enable that
          storage engine while you run <a class="link" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — Check and Upgrade MySQL Tables"><span class="command"><strong>mysql_upgrade</strong></span></a>,
          then disable it again when you restart the server. For more
          information, see <a class="xref" href="programs.html#mysql-upgrade" title="4.4.7 mysql_upgrade — Check and Upgrade MySQL Tables">Section 4.4.7, “<span class="command"><strong>mysql_upgrade</strong></span> — Check and Upgrade MySQL Tables”</a>.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h5 class="title"><a name="group-replication-configure-replication-framework"></a>Replication Framework</h5>

</div>

</div>

</div>
<p>
          The following settings configure replication according to the
          MySQL Group Replication requirements.
        </p><pre data-lang="ini" class="programlisting">
server_id=1
gtid_mode=ON
enforce_gtid_consistency=ON
master_info_repository=TABLE
relay_log_info_repository=TABLE
binlog_checksum=NONE
log_slave_updates=ON
log_bin=binlog
binlog_format=ROW
</pre><p>
          These settings configure the server to use the unique
          identifier number 1, to enable global transaction identifiers
          and to store replication metadata in system tables instead of
          files. Additionally, it instructs the server to turn on binary
          logging, use row-based format and disable binary log event
          checksums. For more details see
          <a class="xref" href="group-replication.html#group-replication-requirements" title="17.7.1 Group Replication Requirements">Section 17.7.1, “Group Replication Requirements”</a>.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h5 class="title"><a name="group-replication-configure-plugin"></a>Group Replication Settings</h5>

</div>

</div>

</div>
<p>
          At this point the option file ensures that the server is
          configured and is instructed to instantiate the replication
          infrastructure under a given configuration. The following
          section configures the Group Replication settings for the
          server.
        </p><pre data-lang="ini" class="programlisting">
plugin_load_add='group_replication.so
transaction_write_set_extraction=XXHASH64
group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
group_replication_start_on_boot=off
group_replication_local_address= "s1:33061"
group_replication_group_seeds= "s1:33061,s2:33061,s3:33061"
group_replication_bootstrap_group=off
</pre>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              <code class="option">plugin-load-add</code> adds the Group
              Replication plugin to the list of plugins which the server
              loads at startup. This is preferable in a production
              deployment to installing the plugin manually.
            </p></li><li class="listitem"><p>
              Configuring
              <a class="link" href="group-replication.html#sysvar_group_replication_group_name"><code class="literal">group_replication_group_name</code></a>
              tells the plugin that the group that it is joining, or
              creating, is named
              "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa".
            </p><p>
              The value of
              <a class="link" href="group-replication.html#sysvar_group_replication_group_name"><code class="literal">group_replication_group_name</code></a>
              must be a valid UUID. This UUID is used internally when
              setting GTIDs for Group Replication events in the binary
              log. You can use <code class="literal">SELECT UUID()</code> to
              generate a UUID.
            </p></li><li class="listitem"><p>
              Configuring the
              <a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot"><code class="literal">group_replication_start_on_boot</code></a>
              variable to <code class="literal">off</code> instructs the plugin to
              not start operations automatically when the server starts.
              This is important when setting up Group Replication as it
              ensures you can configure the server before manually
              starting the plugin. Once the member is configured you can
              set
              <a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot"><code class="literal">group_replication_start_on_boot</code></a>
              to <code class="literal">on</code> so that Group Replication starts
              automatically upon server boot.
            </p></li><li class="listitem"><p>
              Configuring
              <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
              sets the network address and port which the member uses
              for internal communication with other members in the
              group. Group Replication uses this address for internal
              member-to-member connections involving remote instances of
              the group communication engine (XCom, a Paxos variant).
</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p>
                This address must be different to the
                <a class="link" href="server-administration.html#sysvar_hostname"><code class="literal">hostname</code></a> and
                <a class="link" href="server-administration.html#sysvar_port"><code class="literal">port</code></a> used for SQL and
                it must not be used for client applications. It must be
                only be used for internal communication between the
                members of the group while running Group Replication.
</p>
</div>
<p>
              The network address configured by
              <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
              must be resolvable by all group members. For example, if
              each server instance is on a different machine with a
              fixed network address, you could use the IP address of the
              machine, such as 10.0.0.1. If you use a host name, you
              must use a fully qualified name, and ensure it is
              resolvable through DNS, correctly configured
              <code class="literal">/etc/hosts</code> files, or other name
              resolution processes. From MySQL 8.0.14, IPv6 addresses
              (or host names that resolve to them) can be used as well
              as IPv4 addresses. A group can contain a mix of members
              using IPv6 and members using IPv4. For more information on
              Group Replication support for IPv6 networks and on mixed
              IPv4 and IPv6 groups, see
              <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/group-replication-ipv6.html" target="_top">Support For IPv6 And For Mixed IPv6 And IPv4 Groups</a>.
            </p><p>
              The recommended port for
              <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
              is 33061.
              <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
              is used by Group Replication as the unique identifier for
              a group member within the replication group. You can use
              the same port for all members of a replication group as
              long as the host names or IP addresses are all different,
              as demonstrated in this tutorial. Alternatively you can
              use the same host name or IP address for all members as
              long as the ports are all different, for example as shown
              in <a class="xref" href="group-replication.html#group-replication-deploying-locally" title="17.2.2 Deploying Group Replication Locally">Section 17.2.2, “Deploying Group Replication Locally”</a>.
            </p></li><li class="listitem"><p>
              Configuring
              <a class="link" href="group-replication.html#sysvar_group_replication_group_seeds"><code class="literal">group_replication_group_seeds</code></a>
              sets the hostname and port of the group members which are
              used by the new member to establish its connection to the
              group. These members are called the seed members. Once the
              connection is established, the group membership
              information is listed at
              <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>.
              Usually the
              <a class="link" href="group-replication.html#sysvar_group_replication_group_seeds"><code class="literal">group_replication_group_seeds</code></a>
              list contains the <code class="literal">hostname:port</code> of each
              of the group member's
              <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>,
              but this is not obligatory and a subset of the group
              members can be chosen as seeds.
</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p>
                The <code class="literal">hostname:port</code> listed in
                <a class="link" href="group-replication.html#sysvar_group_replication_group_seeds"><code class="literal">group_replication_group_seeds</code></a>
                is the seed member's internal network address,
                configured by
                <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
                and not the SQL <code class="literal">hostname:port</code> used
                for client connections, and shown for example in
                <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
                table.
</p>
</div>
<p>
              The server that starts the group does not make use of this
              option, since it is the initial server and as such, it is
              in charge of bootstrapping the group. In other words, any
              existing data which is on the server bootstrapping the
              group is what is used as the data for the next joining
              member. The second server joining asks the one and only
              member in the group to join, any missing data on the
              second server is replicated from the donor data on the
              bootstrapping member, and then the group expands. The
              third server joining can ask any of these two to join,
              data is synchronized to the new member, and then the group
              expands again. Subsequent servers repeat this procedure
              when joining.
</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Warning
</div>
<p>
                When joining multiple servers at the same time, make
                sure that they point to seed members that are already in
                the group. Do not use members that are also joining the
                group as seeds, because they might not yet be in the
                group when contacted.
              </p><p>
                It is good practice to start the bootstrap member first,
                and let it create the group. Then make it the seed
                member for the rest of the members that are joining.
                This ensures that there is a group formed when joining
                the rest of the members.
              </p><p>
                Creating a group and joining multiple members at the
                same time is not supported. It might work, but chances
                are that the operations race and then the act of joining
                the group ends up in an error or a time out.
</p>
</div>
</li><li class="listitem"><p>
              Configuring
              <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
              instructs the plugin whether to bootstrap the group or
              not. In this case, even though s1 is the first member of
              the group we set this variable to off in the option file.
              Instead we configure
              <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
              when the instance is running, to ensure that only one
              member actually bootstraps the group.
</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p>
                The
                <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
                variable must only be enabled on one server instance
                belonging to a group at any time, usually the first time
                you bootstrap the group (or in case the entire group is
                brought down and back up again). If you bootstrap the
                group multiple times, for example when multiple server
                instances have this option set, then they could create
                an artificial split brain scenario, in which two
                distinct groups with the same name exist. Always set
                <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group=off</code></a>
                after the first server instance comes online.
</p>
</div>
</li></ul>
</div>
<p>
          Configuration for all servers in the group is quite similar.
          You need to change the specifics about each server (for
          example <a class="link" href="server-administration.html#sysvar_server_id"><code class="literal">server_id</code></a>,
          <a class="link" href="server-administration.html#sysvar_datadir"><code class="literal">datadir</code></a>,
          <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>).
          This is illustrated later in this tutorial.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-user-credentials"></a>17.2.1.3 User Credentials</h4>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003377840"></a><p>
        Group Replication uses the asynchronous replication protocol to
        achieve
        <a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5 Distributed Recovery">Section 17.9.5, “Distributed Recovery”</a>,
        synchronizing group members before joining them to the group.
        The distributed recovery process relies on a replication channel
        named <code class="literal">group_replication_recovery</code> which is
        used to transfer transactions from donor members to members that
        join the group. Therefore you need to set up a replication user
        with the correct permissions so that Group Replication can
        establish direct member-to-member recovery replication channels.
      </p><p>
        Start the MySQL server instance and then connect a client to it.
        Create a MySQL user with the
        <a class="link" href="security.html#priv_replication-slave"><code class="literal">REPLICATION-SLAVE</code></a> privilege. This
        process can be captured in the binary log and then you can rely
        on distributed recovery to replicate the statements used to
        create the user. Alternatively, you can disable binary logging
        using <code class="literal">SET SQL_LOG_BIN=0;</code> and then create the
        user manually on each member, for example if you want to avoid
        the changes being propagated to other server instances. If you
        do decide to disable binary logging, ensure you renable it once
        you have configured the user.
      </p><p>
        In the following example the user
        <em class="replaceable"><code>rpl_user</code></em> with the password
        <em class="replaceable"><code>password</code></em> is shown. When configuring
        your servers use a suitable user name and password.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE USER <em class="replaceable"><code>rpl_user</code></em>@'%' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';</code></strong>
mysql&gt; <strong class="userinput"><code>FLUSH PRIVILEGES;</code></strong>
</pre><p>
        If binary logging was disabled, enable it again once the user
        has been created using <code class="literal">SET SQL_LOG_BIN=1;</code>.
      </p><p>
        Once the user has been configured, use the
        <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1 CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER TO</code></a> statement to
        configure the server to use the given credentials for the
        <code class="literal">group_replication_recovery</code> replication
        channel the next time it needs to recover its state from another
        member. Issue the following, replacing
        <em class="replaceable"><code>rpl_user</code></em> and
        <em class="replaceable"><code>password</code></em> with the values used when
        creating the user.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' \\
		      FOR CHANNEL 'group_replication_recovery';</code></strong>
      </pre><p>
        Distributed recovery is the first step taken by a server that
        joins the group and does not have the same set of transactions
        as the group members. If these credentials are not set correctly
        for the <code class="literal">group_replication_recovery</code>
        replication channel and the <code class="literal">rpl_user</code> as
        shown, the server cannot connect to the donor members and run
        the distributed recovery process to gain synchrony with the
        other group members, and hence ultimately cannot join the group.
        See <a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5 Distributed Recovery">Section 17.9.5, “Distributed Recovery”</a>.
      </p><p>
        Similarly, if the server cannot correctly identify the other
        members via the server's <code class="literal">hostname</code> the
        recovery process can fail. It is recommended that operating
        systems running MySQL have a properly configured unique
        <code class="literal">hostname</code>, either using DNS or local settings.
        This <code class="literal">hostname</code> can be verified in the
        <code class="literal">Member_host</code> column of the
        <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
        table. If multiple group members externalize a default
        <code class="literal">hostname</code> set by the operating system, there
        is a chance of the member not resolving to the correct member
        address and not being able to join the group. In such a
        situation use <a class="link" href="replication.html#sysvar_report_host"><code class="literal">report_host</code></a> to
        configure a unique <code class="literal">hostname</code> to be
        externalized by each of the servers.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-launching"></a>17.2.1.4 Launching Group Replication</h4>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003345568"></a><p>
        Once server s1 has been configured and started, install the
        Group Replication plugin. If you used
        <code class="literal">plugin_load_add='group_replication.so</code> in the
        option file then the Group Replication plugin is installed and
        you can proceed to the next step. In the event that you decide
        to install the plugin manually, connect to the server and issue
        the following:
      </p><pre data-lang="sql" class="programlisting">
<strong class="userinput"><code>INSTALL PLUGIN group_replication SONAME 'group_replication.so';</code></strong></pre>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p>
          The <code class="literal">mysql.session</code> user must exist before
          you can load Group Replication.
          <code class="literal">mysql.session</code> was added in MySQL version
          5.7.19. If your data dictionary was initialized using an
          earlier version you must perform the MySQL upgrade procedure
          (see <a class="xref" href="installing.html#upgrading" title="2.11 Upgrading MySQL">Section 2.11, “Upgrading MySQL”</a>). If the upgrade is not run,
          Group Replication fails to start with the error message
          <span class="errortext">There was an error when trying to access the server
          with user: mysql.session@localhost. Make sure the user is
          present in the server and that mysql_upgrade was ran after a
          server update.</span>.
</p>
</div>
<p>
        To check that the plugin was installed successfully, issue
        <code class="literal">SHOW PLUGINS;</code> and check the output. It should
        show something like this:
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW PLUGINS;</code></strong>
+----------------------------+----------+--------------------+----------------------+-------------+
| Name                       | Status   | Type               | Library              | License     |
+----------------------------+----------+--------------------+----------------------+-------------+
| binlog                     | ACTIVE   | STORAGE ENGINE     | NULL                 | PROPRIETARY |

(...)

| group_replication          | ACTIVE   | GROUP REPLICATION  | group_replication.so | PROPRIETARY |
+----------------------------+----------+--------------------+----------------------+-------------+</pre>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-bootstrap"></a>17.2.1.5 Bootstrapping the Group</h4>

</div>

</div>

</div>
<p>
        The process of starting a group for the first time is called
        bootstrapping. You use the
        <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
        system variable to bootstrap a group. The bootstrap should only
        be done by a single server, the one that starts the group and
        only once. This is why the value of the
        <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
        option was not stored in the instance's option file. If it is
        saved in the option file, upon restart the server automatically
        bootstraps a second group with the same name. This would result
        in two distinct groups with the same name. The same reasoning
        applies to stopping and restarting the plugin with this option
        set to <code class="literal">ON</code>. Therefore to safely bootstrap the
        group, connect to s1 and issue:
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_bootstrap_group=ON;</code></strong>
mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION;</code></strong>
mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_bootstrap_group=OFF;</code></strong>
</pre><p>
        Once the <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START GROUP_REPLICATION</code></a>
        statement returns, the group has been started. You can check
        that the group is now created and that there is one member in
        it:
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE  |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| group_replication_applier | ce9be252-2b71-11e6-b8f4-00212844f856 |   s1        |       3306  | ONLINE        |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
</pre><p>
        The information in this table confirms that there is a member in
        the group with the unique identifier
        <code class="literal">ce9be252-2b71-11e6-b8f4-00212844f856</code>, that it
        is <code class="literal">ONLINE</code> and is at <code class="literal">s1</code>
        listening for client connections on port
        <code class="literal">3306</code>.
      </p><p>
        For the purpose of demonstrating that the server is indeed in a
        group and that it is able to handle load, create a table and add
        some content to it.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>CREATE DATABASE test;</code></strong>
mysql&gt; <strong class="userinput"><code>USE test;</code></strong>
mysql&gt; <strong class="userinput"><code>CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL);</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO t1 VALUES (1, 'Luis');</code></strong>
</pre><p>
        Check the content of table <code class="literal">t1</code> and the binary
        log.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM t1;</code></strong>
+----+------+
| c1 | c2   |
+----+------+
|  1 | Luis |
+----+------+

mysql&gt; <strong class="userinput"><code>SHOW BINLOG EVENTS;</code></strong>
+---------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------+
| Log_name      | Pos | Event_type     | Server_id | End_log_pos | Info                                                               |
+---------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------+
| binlog.000001 |   4 | Format_desc    |         1 |         123 | Server ver: 5.7.29-log, Binlog ver: 4                              |
| binlog.000001 | 123 | Previous_gtids |         1 |         150 |                                                                    |
| binlog.000001 | 150 | Gtid           |         1 |         211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1'  |
| binlog.000001 | 211 | Query          |         1 |         270 | BEGIN                                                              |
| binlog.000001 | 270 | View_change    |         1 |         369 | view_id=14724817264259180:1                                        |
| binlog.000001 | 369 | Query          |         1 |         434 | COMMIT                                                             |
| binlog.000001 | 434 | Gtid           |         1 |         495 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'  |
| binlog.000001 | 495 | Query          |         1 |         585 | CREATE DATABASE test                                               |
| binlog.000001 | 585 | Gtid           |         1 |         646 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'  |
| binlog.000001 | 646 | Query          |         1 |         770 | use `test`; CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL) |
| binlog.000001 | 770 | Gtid           |         1 |         831 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4'  |
| binlog.000001 | 831 | Query          |         1 |         899 | BEGIN                                                              |
| binlog.000001 | 899 | Table_map      |         1 |         942 | table_id: 108 (test.t1)                                            |
| binlog.000001 | 942 | Write_rows     |         1 |         984 | table_id: 108 flags: STMT_END_F                                    |
| binlog.000001 | 984 | Xid            |         1 |        1011 | COMMIT /* xid=38 */                                                |
+---------------+-----+----------------+-----------+-------------+--------------------------------------------------------------------+
</pre><p>
        As seen above, the database and the table objects were created
        and their corresponding DDL statements were written to the
        binary log. Also, the data was inserted into the table and
        written to the binary log. The importance of the binary log
        entries is illustrated in the following section when the group
        grows and distributed recovery is executed as new members try to
        catch up and become online.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-adding-instances"></a>17.2.1.6 Adding Instances to the Group</h4>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003301968"></a><p>
        At this point, the group has one member in it, server s1, which
        has some data in it. It is now time to expand the group by
        adding the other two servers configured previously.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h5 class="title"><a name="group-replication-adding-a-second-instance"></a>17.2.1.6.1 Adding a Second Instance</h5>
</div>
</div>
</div>
<a class="indexterm" name="idm140572003298576"></a><p>
          In order to add a second instance, server s2, first create the
          configuration file for it. The configuration is similar to the
          one used for server s1, except for things such as the
          <a class="link" href="server-administration.html#sysvar_server_id"><code class="literal">server_id</code></a>. These different
          lines are highlighted in the listing below.
        </p><pre data-lang="ini" class="programlisting">
[mysqld]

#
# Disable other storage engines
#
disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"

#
# Replication configuration parameters
#
server_id=2
gtid_mode=ON
enforce_gtid_consistency=ON
master_info_repository=TABLE
relay_log_info_repository=TABLE
binlog_checksum=NONE
log_slave_updates=ON
log_bin=binlog
binlog_format=ROW

#
# Group Replication configuration
#
transaction_write_set_extraction=XXHASH64
group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
group_replication_start_on_boot=off
group_replication_local_address= "s2:33061"
group_replication_group_seeds= "s1:33061,s2:33061,s3:33061"
group_replication_bootstrap_group= off
</pre><p>
          Similar to the procedure for server s1, with the option file
          in place you launch the server. Then configure the recovery
          credentials as follows. The commands are the same as used when
          setting up server s1 as the user is shared within the group.
          This member needs to have the same replication user configured
          in <a class="xref" href="group-replication.html#group-replication-user-credentials" title="17.2.1.3 User Credentials">Section 17.2.1.3, “User Credentials”</a>. If
          you are relying on distributed recovery to configure the user
          on all members, when s2 connects to the seed s1 the
          replication user is relicated to s1. If you did not have
          binary logging enabled when you configured the user
          credentials on s1, you must create the replication user on s2.
          In this case, connect to s2 and issue:
        </p><pre data-lang="sql" class="programlisting">
<strong class="userinput"><code>SET SQL_LOG_BIN=0;</code></strong>
<strong class="userinput"><code>CREATE USER <em class="replaceable"><code>rpl_user</code></em>@'%' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
<strong class="userinput"><code>GRANT REPLICATION SLAVE ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';</code></strong>
<strong class="userinput"><code>SET SQL_LOG_BIN=1;</code></strong>
<strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' \\
	FOR CHANNEL 'group_replication_recovery';
</code></strong></pre><p>
          If necessary, install the Group Replication plugin, see
          <a class="xref" href="group-replication.html#group-replication-launching" title="17.2.1.4 Launching Group Replication">Section 17.2.1.4, “Launching Group Replication”</a>.
        </p><p>
          Start Group Replication and s2 starts the process of joining
          the group.
        </p><pre data-lang="sql" class="programlisting">
mysql&gt; START GROUP_REPLICATION;
</pre><p>
          Unlike the previous steps that were the same as those executed
          on s1, here there is a difference in that you do
          <span class="emphasis"><em>not</em></span> need to boostrap the group because
          the group already exiists. In other words on s2
          <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
          is set to off, and you do not issue <code class="literal">SET GLOBAL
          group_replication_bootstrap_group=ON;</code> before
          starting Group Replication, because the group has already been
          created and bootstrapped by server s1. At this point server s2
          only needs to be added to the already existing group.
</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Tip
</div>
<p>
            When Group Replication starts successfully and the server
            joins the group it checks the
            <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> variable.
            By setting <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a>
            to ON in the member's configuration file, you can
            ensure that servers which fail when starting Group
            Replication for any reason do not accept transactions. If
            the server should join the group as read-write instance, for
            example as the primary in a single-primary group or as a
            member of a multi-primary group, when the
            <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> variable is
            set to ON then it is set to OFF upon joining the group.
</p>
</div>
<p>
          Checking the
          <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
          table again shows that there are now two
          <span class="emphasis"><em>ONLINE</em></span> servers in the group.
        </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE  |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| group_replication_applier | 395409e1-6dfa-11e6-970b-00212844f856 |   s1        |        3306 | ONLINE        |
| group_replication_applier | ac39f1e6-6dfa-11e6-a69d-00212844f856 |   s2        |        3306 | ONLINE        |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
</pre><p>
          When s2 attempted to join the group,
          <a class="xref" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5 Distributed Recovery">Section 17.9.5, “Distributed Recovery”</a>
          ensured that s2 applied the same transactions which s1 had
          applied. Once this process completed, s2 could join the group
          as a member, and at this point it is marked as ONLINE. In
          other words it must have already caught up with server s1
          automatically. Once s2 is ONLINE, it then begins to process
          transactions with the group. Verify that s2 has indeed
          synchronized with server s1 as follows.
        </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW DATABASES LIKE 'test';</code></strong>
+-----------------+
| Database (test) |
+-----------------+
| test            |
+-----------------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM test.t1;</code></strong>
+----+------+
| c1 | c2   |
+----+------+
|  1 | Luis |
+----+------+

mysql&gt; <strong class="userinput"><code>SHOW BINLOG EVENTS;</code></strong>
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| Log_name      | Pos  | Event_type     | Server_id | End_log_pos | Info                                                               |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| binlog.000001 |    4 | Format_desc    |         2 |         123 | Server ver: 5.7.29-log, Binlog ver: 4                              |
| binlog.000001 |  123 | Previous_gtids |         2 |         150 |                                                                    |
| binlog.000001 |  150 | Gtid           |         1 |         211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1'  |
| binlog.000001 |  211 | Query          |         1 |         270 | BEGIN                                                              |
| binlog.000001 |  270 | View_change    |         1 |         369 | view_id=14724832985483517:1                                        |
| binlog.000001 |  369 | Query          |         1 |         434 | COMMIT                                                             |
| binlog.000001 |  434 | Gtid           |         1 |         495 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'  |
| binlog.000001 |  495 | Query          |         1 |         585 | CREATE DATABASE test                                               |
| binlog.000001 |  585 | Gtid           |         1 |         646 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'  |
| binlog.000001 |  646 | Query          |         1 |         770 | use `test`; CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL) |
| binlog.000001 |  770 | Gtid           |         1 |         831 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4'  |
| binlog.000001 |  831 | Query          |         1 |         890 | BEGIN                                                              |
| binlog.000001 |  890 | Table_map      |         1 |         933 | table_id: 108 (test.t1)                                            |
| binlog.000001 |  933 | Write_rows     |         1 |         975 | table_id: 108 flags: STMT_END_F                                    |
| binlog.000001 |  975 | Xid            |         1 |        1002 | COMMIT /* xid=30 */                                                |
| binlog.000001 | 1002 | Gtid           |         1 |        1063 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:5'  |
| binlog.000001 | 1063 | Query          |         1 |        1122 | BEGIN                                                              |
| binlog.000001 | 1122 | View_change    |         1 |        1261 | view_id=14724832985483517:2                                        |
| binlog.000001 | 1261 | Query          |         1 |        1326 | COMMIT                                                             |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
</pre><p>
          As seen above, the second server has been added to the group
          and it has replicated the changes from server s1 automatically
          using distributed recovery. In other words, the transactions
          applied on s1 up to the point in time that s2 joined the group
          have been replicated to s2.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h5 class="title"><a name="group-replication-adding-additional-instances"></a>17.2.1.6.2 Adding Additional Instances</h5>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003255104"></a><p>
          Adding additional instances to the group is essentially the
          same sequence of steps as adding the second server, except
          that the configuration has to be changed as it had to be for
          server s2. To summarise the required commands:
        </p><p>
          <span class="emphasis"><em>1. Create the configuration file</em></span>
        </p><pre data-lang="ini" class="programlisting">
[mysqld]

#
# Disable other storage engines
#
disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"

#
# Replication configuration parameters
#
server_id=3
gtid_mode=ON
enforce_gtid_consistency=ON
master_info_repository=TABLE
relay_log_info_repository=TABLE
binlog_checksum=NONE
log_slave_updates=ON
log_bin=binlog
binlog_format=ROW

#
# Group Replication configuration
#
group_replication_group_name="aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa"
group_replication_start_on_boot=off
group_replication_local_address= "s3:33061"
group_replication_group_seeds= "s1:33061,s2:33061,s3:33061"
group_replication_bootstrap_group= off
</pre><p>
          <span class="emphasis"><em>2. Start the server and connect to it. Configure the
          recovery credentials for the group_replication_recovery
          channel.</em></span>
        </p><pre data-lang="sql" class="programlisting">
SET SQL_LOG_BIN=0;
CREATE USER <em class="replaceable"><code>rpl_user</code></em>@'%' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';
GRANT REPLICATION SLAVE ON *.* TO <em class="replaceable"><code>rpl_user</code></em>@'%';
FLUSH PRIVILEGES;
SET SQL_LOG_BIN=1;
CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>'  \\
FOR CHANNEL 'group_replication_recovery';</pre><p>
          <span class="emphasis"><em>4. Install the Group Replication plugin and start
          it.</em></span>
        </p><pre data-lang="sql" class="programlisting">
INSTALL PLUGIN group_replication SONAME 'group_replication.so';
START GROUP_REPLICATION;</pre><p>
          At this point server s3 is booted and running, has joined the
          group and caught up with the other servers in the group.
          Consulting the
          <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
          table again confirms this is the case.
        </p><pre data-lang="sql" class="programlisting">
mysql&gt; SELECT * FROM performance_schema.replication_group_members;
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| CHANNEL_NAME              | MEMBER_ID                            | MEMBER_HOST | MEMBER_PORT | MEMBER_STATE  |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
| group_replication_applier | 395409e1-6dfa-11e6-970b-00212844f856 |   s1        |       3306  | ONLINE        |
| group_replication_applier | 7eb217ff-6df3-11e6-966c-00212844f856 |   s3        |       3306  | ONLINE        |
| group_replication_applier | ac39f1e6-6dfa-11e6-a69d-00212844f856 |   s2        |       3306  | ONLINE        |
+---------------------------+--------------------------------------+-------------+-------------+---------------+
</pre><p>
          Issuing this same query on server s2 or server s1 yields the
          same result. Also, you can verify that server s3 has caught
          up:
        </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW DATABASES LIKE 'test';</code></strong>
+-----------------+
| Database (test) |
+-----------------+
| test            |
+-----------------+

mysql&gt; <strong class="userinput"><code>SELECT * FROM test.t1;</code></strong>
+----+------+
| c1 | c2   |
+----+------+
|  1 | Luis |
+----+------+

mysql&gt; <strong class="userinput"><code>SHOW BINLOG EVENTS;</code></strong>
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| Log_name      | Pos  | Event_type     | Server_id | End_log_pos | Info                                                               |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
| binlog.000001 |    4 | Format_desc    |         3 |         123 | Server ver: 5.7.29-log, Binlog ver: 4                              |
| binlog.000001 |  123 | Previous_gtids |         3 |         150 |                                                                    |
| binlog.000001 |  150 | Gtid           |         1 |         211 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:1'  |
| binlog.000001 |  211 | Query          |         1 |         270 | BEGIN                                                              |
| binlog.000001 |  270 | View_change    |         1 |         369 | view_id=14724832985483517:1                                        |
| binlog.000001 |  369 | Query          |         1 |         434 | COMMIT                                                             |
| binlog.000001 |  434 | Gtid           |         1 |         495 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:2'  |
| binlog.000001 |  495 | Query          |         1 |         585 | CREATE DATABASE test                                               |
| binlog.000001 |  585 | Gtid           |         1 |         646 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:3'  |
| binlog.000001 |  646 | Query          |         1 |         770 | use `test`; CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 TEXT NOT NULL) |
| binlog.000001 |  770 | Gtid           |         1 |         831 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:4'  |
| binlog.000001 |  831 | Query          |         1 |         890 | BEGIN                                                              |
| binlog.000001 |  890 | Table_map      |         1 |         933 | table_id: 108 (test.t1)                                            |
| binlog.000001 |  933 | Write_rows     |         1 |         975 | table_id: 108 flags: STMT_END_F                                    |
| binlog.000001 |  975 | Xid            |         1 |        1002 | COMMIT /* xid=29 */                                                |
| binlog.000001 | 1002 | Gtid           |         1 |        1063 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:5'  |
| binlog.000001 | 1063 | Query          |         1 |        1122 | BEGIN                                                              |
| binlog.000001 | 1122 | View_change    |         1 |        1261 | view_id=14724832985483517:2                                        |
| binlog.000001 | 1261 | Query          |         1 |        1326 | COMMIT                                                             |
| binlog.000001 | 1326 | Gtid           |         1 |        1387 | SET @@SESSION.GTID_NEXT= 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:6'  |
| binlog.000001 | 1387 | Query          |         1 |        1446 | BEGIN                                                              |
| binlog.000001 | 1446 | View_change    |         1 |        1585 | view_id=14724832985483517:3                                        |
| binlog.000001 | 1585 | Query          |         1 |        1650 | COMMIT                                                             |
+---------------+------+----------------+-----------+-------------+--------------------------------------------------------------------+
</pre>
</div>

</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-deploying-locally"></a>17.2.2 Deploying Group Replication Locally</h3>

</div>

</div>

</div>
<p>
      

      The most common way to deploy Group Replication is using multiple
      server instances, to provide high availability. It is also
      possible to deploy Group Replication locally, for example for
      testing purposes. This section explains how you can deploy Group
      Replication locally.
</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p>
        Group Replication is usually deployed on multiple hosts because
        this ensures that high-availability is provided. The
        instructions in this section are not suitable for production
        deployments because all MySQL server instances are running on
        the same single host. In the event of failure of this host, the
        whole group fails. Therefore this information should be used for
        testing purposes and it should not be used in a production
        environments.
</p>
</div>
<p>
      This section explains how to create a replication group with three
      MySQL Server instances on one physical machine. This means that
      three data directories are needed, one per server instance, and
      that you need to configure each instance independently. This -
      procedure assumes that MySQL Server was downloaded and unpacked -
      into the directory named <code class="literal">mysql-5.7</code>. Each MySQL
      server instance requires a specific data directory. Create a
      directory named <code class="literal">data</code>, then in that directory
      create a subdirectory for each server instance, for example s1, s2
      and s3, and initialize each one.
    </p><pre data-lang="terminal" class="programlisting">
<strong class="userinput"><code>mysql-5.7/bin/mysqld --initialize-insecure --basedir=$PWD/mysql-5.7 --datadir=$PWD/data/s1</code></strong>
<strong class="userinput"><code>mysql-5.7/bin/mysqld --initialize-insecure --basedir=$PWD/mysql-5.7 --datadir=$PWD/data/s2</code></strong>
<strong class="userinput"><code>mysql-5.7/bin/mysqld --initialize-insecure --basedir=$PWD/mysql-5.7 --datadir=$PWD/data/s3</code></strong>
</pre><p>
      Inside <code class="literal">data/s1</code>, <code class="literal">data/s2</code>,
      <code class="literal">data/s3</code> is an initialized data directory,
      containing the mysql system database and related tables and much
      more. To learn more about the initialization procedure, see
      <a class="xref" href="installing.html#data-directory-initialization" title="2.10.1 Initializing the Data Directory">Section 2.10.1, “Initializing the Data Directory”</a>.
</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Warning
</div>
<p>
        Do not use <code class="literal">-initialize-insecure</code> in production
        environments, it is only used here to simplify the tutorial. For
        more information on security settings, see
        <a class="xref" href="group-replication.html#group-replication-security" title="17.5 Group Replication Security">Section 17.5, “Group Replication Security”</a>.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="configure-local-group-members"></a>Configuration of Local Group Replication Members</h4>

</div>

</div>

</div>
<p>
        When you are following
        <a class="xref" href="group-replication.html#group-replication-configuring-instances" title="17.2.1.2 Configuring an Instance for Group Replication">Section 17.2.1.2, “Configuring an Instance for Group Replication”</a>, you
        need to add configuration for the data directories added in the
        previous section. For example:
      </p><pre data-lang="ini" class="programlisting">
[mysqld]

# server configuration
datadir=&lt;full_path_to_data&gt;/data/s1
basedir=&lt;full_path_to_bin&gt;/mysql-8.0/

port=24801
socket=&lt;full_path_to_sock_dir&gt;/s1.sock</pre><p>
        These settings configure MySQL server to use the data directory
        created earlier and which port the server should open and start
        listening for incoming connections.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
          The non-default port of 24801 is used because in this tutorial
          the three server instances use the same hostname. In a setup
          with three different machines this would not be required.
</p>
</div>
<p>
        Group Replication requires a network connection between the
        members, which means that each member must be able to resolve
        the network address of all of the other members. For example in
        this tutorial all three instances run on one machine, so to
        ensure that the members can contact each other you could add a
        line to the option file such as
        <a class="link" href="replication.html#sysvar_report_host"><code class="literal">report_host=127.0.0.1</code></a>.
      </p><p>
        Then each member needs to be able to connect to the other
        members on their
        <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>.
        For example in the option file of member s1 add:
      </p><pre data-lang="ini" class="programlisting">
group_replication_local_address= "127.0.0.1:24901"
group_replication_group_seeds= "127.0.0.1:24901,127.0.0.1:24902,127.0.0.1:24903"
</pre><p>
        This configures s1 to use port 24901 for internal group
        communication with seed members. For each server instance you
        want to add to the group, make these changes in the option file
        of the member. For each member you must ensure a unique address
        is specified, so use a unique port per instance for
        <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>.
        Usually you want all members to be able to serve as seeds for
        members that are joining the group and have not got the
        transactions processed by the group. In this case, add all of
        the ports to
        <a class="link" href="group-replication.html#sysvar_group_replication_group_seeds"><code class="literal">group_replication_group_seeds</code></a>
        as shown above.
      </p><p>
        The remaining steps of
        <a class="xref" href="group-replication.html#group-replication-deploying-in-single-primary-mode" title="17.2.1 Deploying Group Replication in Single-Primary Mode">Section 17.2.1, “Deploying Group Replication in Single-Primary Mode”</a>
        apply equally to a group which you have deployed locally in this
        way.
</p>
</div>

</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="group-replication-monitoring"></a>17.3 Monitoring Group Replication</h2>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-server-states">17.3.1 Group Replication Server States</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-members">17.3.2 The replication_group_members Table</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-replication-group-member-stats">17.3.3 The replication_group_member_stats Table</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572146624240"></a><p>
    Use the Perfomance Schema tables to monitor Group Replication,
    assuming that the
    <a class="ulink" href="performance-schema-quick-start" target="_top">Performance
    Schema</a> is enabled. Group Replication adds the following
    tables:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="performance-schema.html#replication-group-member-stats-table" title="25.12.11.8 The replication_group_member_stats Table"><code class="literal">performance_schema.replication_group_member_stats</code></a>
      </p></li><li class="listitem"><p>
        <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
</p></li></ul>
</div>
<p>
    These Perfomance Schema replication tables also show information
    about Group Replication:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="performance-schema.html#replication-connection-status-table" title="25.12.11.2 The replication_connection_status Table"><code class="literal">performance_schema.replication_connection_status</code></a>
        shows information regarding Group Replication, for example the
        transactions that have been received from the group and queued
        in the applier queue (the relay log).
      </p></li><li class="listitem"><p>
        <a class="link" href="performance-schema.html#replication-applier-status-table" title="25.12.11.4 The replication_applier_status Table"><code class="literal">performance_schema.replication_applier_status</code></a>
        shows the state of the Group Replication related channels and
        threads If there are many different worker threads applying
        transactions, then the worker tables can also be used to monitor
        what each worker thread is doing.
</p></li></ul>
</div>
<p>
    The replication channels created by the Group Replication plugin are
    named:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <code class="literal">group_replication_recovery</code> - This channel is
        used for the replication changes that are related to the
        distributed recovery phase.
      </p></li><li class="listitem"><p>
        <code class="literal">group_replication_applier</code> - This channel is
        used for the incoming changes from the group. This is the
        channel used to apply transactions coming directly from the
        group.
</p></li></ul>
</div>
<p>
    The following sections describe how to interpret the information
    available.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-server-states"></a>17.3.1 Group Replication Server States</h3>
</div>
</div>
</div>
<a class="indexterm" name="idm140572146606160"></a><p>
      There are various states that a server instance can be in. If
      servers are communicating properly, all report the same states for
      all servers. However, if there is a network partition, or a server
      leaves the group, then different information could be reported,
      depending on which server is queried. If the server has left the
      group then it cannot report updated information about the other
      servers' states. If there is a partition, such that quorum is
      lost, servers are not able to coordinate between themselves. As a
      consequence, they cannot guess what the status of different
      servers is. Therefore, instead of guessing their state they report
      that some servers are unreachable.
</p>
<div class="table">
<a name="idm140572146603520"></a><p class="title"><b>Table 17.1 Server State</b></p>
<div class="table-contents">
<table><col width="38%"><col width="50%"><col width="12%"><thead><tr>
          <th scope="col"><p>
              Field
            </p></th>
          <th scope="col"><p>
              Description
            </p></th>
          <th scope="col"><p>
              Group Synchronized
            </p></th>
        </tr></thead><tbody><tr>
          <td scope="row"><p>
              <code class="literal">ONLINE</code>
            </p></td>
          <td><p>
              The member is ready to serve as a fully functional group
              member, meaning that the client can connect and start
              executing transactions.
            </p></td>
          <td><p>
              Yes
            </p></td>
        </tr><tr>
          <td scope="row"><p>
              <code class="literal">RECOVERING</code>
            </p></td>
          <td><p>
              The member is in the process of becoming an active member
              of the group and is currently going through the recovery
              process, receiving state information from a donor.
            </p></td>
          <td><p>
              No
            </p></td>
        </tr><tr>
          <td scope="row"><p>
              <code class="literal">OFFLINE</code>
            </p></td>
          <td><p>
              The plugin is loaded but the member does not belong to any
              group.
            </p></td>
          <td><p>
              No
            </p></td>
        </tr><tr>
          <td scope="row"><p>
              <code class="literal">ERROR</code>
            </p></td>
          <td><p>
              The state of the member. Whenever there is an error on the
              recovery phase or while applying changes, the server
              enters this state.
            </p></td>
          <td><p>
              No
            </p></td>
        </tr><tr>
          <td scope="row"><p>
              <code class="literal">UNREACHABLE</code>
            </p></td>
          <td><p>
              Whenever the local failure detector suspects that a given
              server is not reachable, because for example it was
              disconnected involuntarily, it shows that server's state
              as <code class="literal">UNREACHABLE</code>.
            </p></td>
          <td><p>
              No
            </p></td>
</tr></tbody></table>
</div>

</div>
<br class="table-break">
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p>
        Once an instance enters <code class="literal">ERROR</code> state, the
        <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> option is set
        to <code class="literal">ON</code>. To leave the <code class="literal">ERROR</code>
        state you must manually configure the instance with
        <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only=OFF</code></a>.
</p>
</div>
<p>
      Note that Group Replication is <span class="emphasis"><em>not</em></span>
      synchronous, but eventually synchronous. More precisely,
      transactions are delivered to all group members in the same order,
      but their execution is not synchronized, meaning that after a
      transaction is accepted to be committed, each member commits at
      its own pace.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-replication-group-members"></a>17.3.2 The replication_group_members Table</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572146564432"></a><p>
      The
      <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>
      table is used for monitoring the status of the different server
      instances that are members of the group. The information in the
      table is updated whenever there is a view change, for example when
      the configuration of the group is dynamically changed when a new
      member joins. At that point, servers exchange some of their
      metadata to synchronize themselves and continue to cooperate
      together. The information is shared between all the server
      instances that are members of the replication group, so
      information on all the group members can be queried from any
      member. This table can be used to get a high level view of the
      state of a replication group, for example by issuing:
    </p><pre data-lang="sql" class="programlisting">
<strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+---------------------------+--------------------------------------+--------------+-------------+--------------+
| CHANNEL_NAME              | MEMBER_ID	                           | MEMBER_HOST  | MEMBER_PORT | MEMBER_STATE | 
+---------------------------+--------------------------------------+--------------+-------------+--------------+
| group_replication_applier | 041f26d8-f3f3-11e8-adff-080027337932 | example1     |      3306   | ONLINE       | 
| group_replication_applier | f60a3e10-f3f2-11e8-8258-080027337932 | example2     |      3306   | ONLINE       | 
| group_replication_applier | fc890014-f3f2-11e8-a9fd-080027337932 | example3     |      3306   | ONLINE       | 
+---------------------------+--------------------------------------+--------------+-------------+--------------+
</pre><p>
      Based on this result we can see that the group consists of three
      members, each member's host and port number which clients use to
      connect to the member, and the
      <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> of the member. The
      <code class="literal">MEMBER_STATE</code> column shows one of the
      <a class="xref" href="group-replication.html#group-replication-server-states" title="17.3.1 Group Replication Server States">Section 17.3.1, “Group Replication Server States”</a>, in this case it
      shows that all three members in this group are
      <code class="literal">ONLINE</code>, and the <code class="literal">MEMBER_ROLE</code>
      column shows that there are two secondaries, and a single primary.
      Therefore this group must be running in single-primary mode. The
      <code class="literal">MEMBER_VERSION</code> column can be useful when you
      are upgrading a group and are combining members running different
      MySQL versions. See
      <a class="xref" href="group-replication.html#group-replication-server-states" title="17.3.1 Group Replication Server States">Section 17.3.1, “Group Replication Server States”</a> for more
      information.
    </p><p>
      For more information about the <code class="literal">Member_host</code>
      value and its impact on the distributed recovery process, see
      <a class="xref" href="group-replication.html#group-replication-user-credentials" title="17.2.1.3 User Credentials">Section 17.2.1.3, “User Credentials”</a>.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-replication-group-member-stats"></a>17.3.3 The replication_group_member_stats Table</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003219392"></a><p>
      Each member in a replication group certifies and applies
      transactions received by the group. Statistics regarding the
      certifier and applier procedures are useful to understand how the
      applier queue is growing, how many conflicts have been found, how
      many transactions were checked, which transactions are committed
      everywhere, and so on.
    </p><p>
      The
      <a class="link" href="performance-schema.html#replication-group-member-stats-table" title="25.12.11.8 The replication_group_member_stats Table"><code class="literal">performance_schema.replication_group_member_stats</code></a>
      table provides group-level information related to the
      certification process, and also statistics for the transactions
      received and originated by each individual member of the
      replication group. The information is shared between all the
      server instances that are members of the replication group, so
      information on all the group members can be queried from any
      member. Note that refreshing of statistics for remote members is
      controlled by the message period specified in the
      <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/group-replication-options.html#sysvar_group_replication_flow_control_period" target="_top"><code class="literal">group_replication_flow_control_period</code></a>
      option, so these can differ slightly from the locally collected
      statistics for the member where the query is made. To use this
      table to monitor a Group Replication member, issue:
    </p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_member_stats\G</code></strong></pre><p>
      These fields are important for monitoring the performance of the
      members connected in the group. For example, suppose that one of
      the group’s members always reports a large number of
      transactions in its queue compared to other members. This means
      that the member is delayed and is not able to keep up to date with
      the other members of the group. Based on this information, you
      could decide to either remove the member from the group, or delay
      the processing of transactions on the other members of the group
      in order to reduce the number of queued transactions. This
      information can also help you to decide how to adjust the flow
      control of the Group Replication plugin, see
      <a class="xref" href="group-replication.html#group-replication-flow-control" title="17.9.7.3 Flow Control">Section 17.9.7.3, “Flow Control”</a>.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="group-replication-operations"></a>17.4 Group Replication Operations</h2>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-deploying-in-multi-primary-or-single-primary-mode">17.4.1 Deploying in Multi-Primary or Single-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-tuning-recovery">17.4.2 Tuning Recovery</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-network-partitioning">17.4.3 Network Partitioning</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-enterprise-backup">17.4.4 Using MySQL Enterprise Backup with Group Replication</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572003209568"></a><p>
    This section describes the different modes of deploying Group
    Replication, explains common operations for managing groups and
    provides information about how to tune your groups.

    

    .
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-deploying-in-multi-primary-or-single-primary-mode"></a>17.4.1 Deploying in Multi-Primary or Single-Primary Mode</h3>

</div>

</div>

</div>

<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-single-primary-mode">17.4.1.1 Single-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-multi-primary-mode">17.4.1.2 Multi-Primary Mode</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-find-primary">17.4.1.3 Finding the Primary</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572003205840"></a><a class="indexterm" name="idm140572003204448"></a><a class="indexterm" name="idm140572003203056"></a><p>
      Group Replication operates in the following different modes:

</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            single-primary mode
          </p></li><li class="listitem"><p>
            multi-primary mode
</p></li></ul>
</div>
<p>

      The default mode is single-primary. It is not possible to have
      members of the group deployed in different modes, for example one
      configured in multi-primary mode while another one is in
      single-primary mode. To switch between modes, the group and not
      the server, needs to be restarted with a different operating
      configuration. Regardless of the deployed mode, Group Replication
      does not handle client-side fail-over, that must be handled by the
      application itself, a connector or a middleware framework such as
      a proxy or <a class="ulink" href="https://dev.mysql.com/doc/mysql-router/8.0/en/" target="_top">MySQL Router 8.0</a>.
    </p><p>
      When deployed in multi-primary mode, statements are checked to
      ensure they are compatible with the mode. The following checks are
      made when Group Replication is deployed in multi-primary mode:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          If a transaction is executed under the SERIALIZABLE isolation
          level, then its commit fails when synchronizing itself with
          the group.
        </p></li><li class="listitem"><p>
          If a transaction executes against a table that has foreign
          keys with cascading constraints, then the transaction fails to
          commit when synchronizing itself with the group.
</p></li></ul>
</div>
<p>
      These checks can be deactivated by setting the option
      <a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks"><code class="literal">group_replication_enforce_update_everywhere_checks</code></a>
      to <code class="literal">FALSE</code>. When deploying in single-primary
      mode, this option <span class="emphasis"><em>must</em></span> be set to
      <code class="literal">FALSE</code>.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-single-primary-mode"></a>17.4.1.1 Single-Primary Mode</h4>
</div>
</div>
</div>
<a class="indexterm" name="idm140572003190960"></a><a class="indexterm" name="idm140572003189568"></a><p>
        In this mode the group has a single-primary server that is set
        to read-write mode. All the other members in the group are set
        to read-only mode (with
        <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super-read-only=ON</code></a>

        

        ). This happens automatically. The primary is typically the
        first server to bootstrap the group, all other servers that join
        automatically learn about the primary server and are set to read
        only.
</p>
<div class="figure">
<a name="idm140572003185728"></a><p class="title"><b>Figure 17.5 New Primary Election</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/single-primary-election.png" width="948" height="327" alt="Five server instances, S1, S2, S3, S4, and S5, are deployed as an interconnected group. Server S1 is the primary. Write clients are communicating with server S1, and a read client is communicating with server S4. Server S1 then fails, breaking communication with the write clients. Server S2 then takes over as the new primary, and the write clients now communicate with server S2.">
</div>

</div>

</div>
<br class="figure-break"><p>
        When in single-primary mode, some of the checks deployed in
        multi-primary mode are disabled, because the system enforces
        that only a single server writes to the group. For example,
        changes to tables that have cascading foreign keys are allowed,
        whereas in multi-primary mode they are not. Upon primary member
        failure, an automatic primary election mechanism chooses the new
        primary member. The election process is performed by looking at
        the new view, and ordering the potential new primaries based on
        the value of
        <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>.
        Assuming the group is operating with all members running the
        same MySQL version, then the member with the highest value for
        <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>
        is elected as the new primary. In the event that multiple
        servers have the same
        <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>,
        the servers are then prioritized based on their
        <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> in lexicographical
        order and by picking the first one. Once a new primary is
        elected, it is automatically set to read-write and the other
        secondaries remain as secondaries, and as such, read-only.
      </p><p>
        When a new primary is elected, it is only writable once it has
        processed all of the transactions that came from the old
        primary. This avoids possible concurrency issues between old
        transactions from the old primary and the new ones being
        executed on this member. It is a good practice to wait for the
        new primary to apply its replication related relay-log before
        re-routing client applications to it.
      </p><p>
        If the group is operating with members that are running
        different versions of MySQL then the election process can be
        impacted. For example, if any member does not support
        <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>,
        then the primary is chosen based on
        <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> order from the
        members of the lower major version. Alternatively, if all
        members running different MySQL versions do support
        <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>,
        the primary is chosen based on
        <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>
        from the members of the lower major version.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-multi-primary-mode"></a>17.4.1.2 Multi-Primary Mode</h4>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003167168"></a><p>
        In multi-primary mode, there is no notion of a single primary.
        There is no need to engage an election procedure because there
        is no server playing any special role.
</p>
<div class="figure">
<a name="idm140572003165184"></a><p class="title"><b>Figure 17.6 Client Failover</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/multi-primary.png" width="948" height="327" alt="Five server instances, S1, S2, S3, S4, and S5, are deployed as an interconnected group. All of the servers are primaries. Write clients are communicating with servers S1 and S2, and a read client is communicating with server S4. Server S1 then fails, breaking communication with its write client. This client reconnects to server S3.">
</div>

</div>

</div>
<br class="figure-break"><p>
        All servers are set to read-write mode when joining the group.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-find-primary"></a>17.4.1.3 Finding the Primary</h4>

</div>

</div>

</div>
<p>
        The following example shows how to find out which server is
        currently the primary when deployed in single-primary mode.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'group_replication_primary_member'</code></strong>
</pre>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-tuning-recovery"></a>17.4.2 Tuning Recovery</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003154272"></a><p>
      Whenever a new member joins a replication group, it connects to a
      suitable donor and fetches the data that it has missed up until
      the point it is declared online. This critical component in Group
      Replication is fault tolerant and configurable. The following
      section explains how recovery works and how to tune the settings
</p>
<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h4 class="title"><a name="group-replication-donor-selection"></a>Donor Selection</h4>
</div>
</div>
</div>
<p>
        A random donor is selected from the existing online members in
        the group. This way there is a good chance that the same server
        is not selected more than once when multiple members enter the
        group.
      </p><p>
        If the connection to the selected donor fails, a new connection
        is automatically attempted to a new candidate donor. Once the
        connection retry limit is reached the recovery procedure
        terminates with an error.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
          A donor is picked randomly from the list of online members in
          the current view.
</p>
</div>

</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="group-replication-enhanced-automatic-donor-switchover"></a>Enhanced Automatic Donor Switchover</h4>

</div>

</div>

</div>
<p>
        The other main point of concern in recovery as a whole is to
        make sure that it copes with failures. Hence, Group Replication
        provides robust error detection mechanisms. In earlier versions
        of Group Replication, when reaching out to a donor, recovery
        could only detect connection errors due to authentication issues
        or some other problem. The reaction to such problematic
        scenarios was to switch over to a new donor thus a new
        connection attempt was made to a different member.

        
      </p><p>
        This behavior was extended to also cover other failure
        scenarios:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>Purged data scenarios</em></span> - If the selected
            donor contains some purged data that is needed for the
            recovery process then an error occurs. Recovery detects this
            error and a new donor is selected.
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>Duplicated data</em></span> - If a server joining
            the group already contains some data that conflicts with the
            data coming from the selected donor during recovery then an
            error occurs. This could be caused by some errant
            transactions present in the server joining the group.
          </p><p>
            One could argue that recovery should fail instead of
            switching over to another donor, but in heterogeneous groups
            there is chance that other members share the conflicting
            transactions and others do not. For that reason, upon error,
            recovery selects another donor from the group.
          </p></li><li class="listitem"><p>
            <span class="emphasis"><em>Other errors</em></span> - If any of the recovery
            threads fail (receiver or applier threads fail) then an
            error occurs and recovery switches over to a new donor.
</p></li></ul>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<div class="admon-title">
Note
</div>
<p>
          In case of some persistent failures or even transient failures
          recovery automatically retries connecting to the same or a new
          donor.
</p>
</div>

</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="group-replication-donor-connection-retries"></a>Donor Connection Retries</h4>

</div>

</div>

</div>
<p>
        The recovery data transfer relies on the binary log and existing
        MySQL replication framework, therefore it is possible that some
        transient errors could cause errors in the receiver or applier
        threads. In such cases, the donor switch over process has retry
        functionality, similar to that found in regular replication.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="group-replication-number-of-attempts"></a>Number of Attempts</h4>

</div>

</div>

</div>
<p>
        The number of attempts a server joining the group makes when
        trying to connect to a donor from the pool of donors is 10. This
        is configured through the
        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_retry_count"><code class="literal">group_replication_recovery_retry_count</code></a>
        plugin variable . The following command sets the maximum number
        of attempts to connect to a donor to 10.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_recovery_retry_count= 10;</code></strong>
</pre><p>
        Note that this accounts for the global number of attempts that
        the server joining the group makes connecting to each one of the
        suitable donors.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="group-replication-sleep-routines"></a>Sleep Routines</h4>

</div>

</div>

</div>
<p>
        The
        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_reconnect_interval"><code class="literal">group_replication_recovery_reconnect_interval</code></a>
        plugin variable defines how much time the recovery process
        should sleep between donor connection attempts. This variable
        has its default set to 60 seconds and you can change this value
        dynamically. The following command sets the recovery donor
        connection retry interval to 120 seconds.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_recovery_reconnect_interval= 120;</code></strong>
</pre><p>
        Note, however, that recovery does not sleep after every donor
        connection attempt. As the server joining the group is
        connecting to different servers and not to the same one over and
        over again, it can assume that the problem that affects server A
        does not affect server B. As such, recovery suspends only when
        it has gone through all the possible donors. Once the server
        joining the group has tried to connect to all the suitable
        donors in the group and none remains, the recovery process
        sleeps for the number of seconds configured by the
        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_reconnect_interval"><code class="literal">group_replication_recovery_reconnect_interval</code></a>
        variable.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-network-partitioning"></a>17.4.3 Network Partitioning</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003125200"></a><p>
      The group needs to achieve consensus whenever a change that needs
      to be replicated happens. This is the case for regular
      transactions but is also required for group membership changes and
      some internal messaging that keeps the group consistent. Consensus
      requires a majority of group members to agree on a given decision.
      When a majority of group members is lost, the group is unable to
      progress and blocks because it cannot secure majority or quorum.
    </p><p>
      Quorum may be lost when there are multiple involuntary failures,
      causing a majority of servers to be removed abruptly from the
      group. For example in a group of 5 servers, if 3 of them become
      silent at once, the majority is compromised and thus no quorum can
      be achieved. In fact, the remaining two are not able to tell if
      the other 3 servers have crashed or whether a network partition
      has isolated these 2 alone and therefore the group cannot be
      reconfigured automatically.
    </p><p>
      On the other hand, if servers exit the group voluntarily, they
      instruct the group that it should reconfigure itself. In practice,
      this means that a server that is leaving tells others that it is
      going away. This means that other members can reconfigure the
      group properly, the consistency of the membership is maintained
      and the majority is recalculated. For example, in the above
      scenario of 5 servers where 3 leave at once, if the 3 leaving
      servers warn the group that they are leaving, one by one, then the
      membership is able to adjust itself from 5 to 2, and at the same
      time, securing quorum while that happens.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
        Loss of quorum is by itself a side-effect of bad planning. Plan
        the group size for the number of expected failures (regardless
        whether they are consecutive, happen all at once or are
        sporadic).

        
</p>
</div>
<p>
      The following sections explain what to do if the system partitions
      in such a way that no quorum is automatically achieved by the
      servers in the group.
</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Tip
</div>
<p>
        A primary that has been excluded from a group after a majority
        loss followed by a reconfiguration can contain extra
        transactions that are not included in the new group. If this
        happens, the attempt to add back the excluded member from the
        group results in an error with the message <span class="errortext">This
        member has more executed transactions than those present in the
        group.</span>
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="group-replication-detecting-partitions"></a>Detecting Partitions</h4>

</div>

</div>

</div>
<p>
        The <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">replication_group_members</code></a>
        performance schema table presents the status of each server in
        the current view from the perspective of this server. The
        majority of the time the system does not run into partitioning,
        and therefore the table shows information that is consistent
        across all servers in the group. In other words, the status of
        each server on this table is agreed by all in the current view.
        However, if there is network partitioning, and quorum is lost,
        then the table shows the status <code class="literal">UNREACHABLE</code>
        for those servers that it cannot contact. This information is
        exported by the local failure detector built into Group
        Replication.
</p>
<div class="figure">
<a name="idm140572003113344"></a><p class="title"><b>Figure 17.7 Losing Quorum</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-majority-lost.png" width="265" height="417" alt="Five server instances, S1, S2, S3, S4, and S5, are deployed as an interconnected group, which is a stable group. When three of the servers, S3, S4, and S5, fail, the majority is lost and the group can no longer proceed without intervention.">
</div>

</div>

</div>
<br class="figure-break"><p>
        To understand this type of network partition the following
        section describes a scenario where there are initially 5 servers
        working together correctly, and the changes that then happen to
        the group once only 2 servers are online. The scenario is
        depicted in the

        

        figure.
      </p><p>
        As such, lets assume that there is a group with these 5 servers
        in it:

        
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Server s1 with member identifier
            <code class="literal">199b2df7-4aaf-11e6-bb16-28b2bd168d07</code>
          </p></li><li class="listitem"><p>
            Server s2 with member identifier
            <code class="literal">199bb88e-4aaf-11e6-babe-28b2bd168d07</code>
          </p></li><li class="listitem"><p>
            Server s3 with member identifier
            <code class="literal">1999b9fb-4aaf-11e6-bb54-28b2bd168d07</code>
          </p></li><li class="listitem"><p>
            Server s4 with member identifier
            <code class="literal">19ab72fc-4aaf-11e6-bb51-28b2bd168d07</code>
          </p></li><li class="listitem"><p>
            Server s5 with member identifier
            <code class="literal">19b33846-4aaf-11e6-ba81-28b2bd168d07</code>
</p></li></ul>
</div>
<p>
        Initially the group is running fine and the servers are happily
        communicating with each other. You can verify this by logging
        into s1 and looking at its
        <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">replication_group_members</code></a>
        performance schema table. For example:
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE, MEMBER_ROLE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+-------------+
| MEMBER_ID                            | MEMBER_STATE |-MEMBER_ROLE |
+--------------------------------------+--------------+-------------+
| 1999b9fb-4aaf-11e6-bb54-28b2bd168d07 | ONLINE       | SECONDARY   |
| 199b2df7-4aaf-11e6-bb16-28b2bd168d07 | ONLINE       | PRIMARY     |
| 199bb88e-4aaf-11e6-babe-28b2bd168d07 | ONLINE       | SECONDARY   |
| 19ab72fc-4aaf-11e6-bb51-28b2bd168d07 | ONLINE       | SECONDARY   |
| 19b33846-4aaf-11e6-ba81-28b2bd168d07 | ONLINE       | SECONDARY   |
+--------------------------------------+--------------+-------------+
</pre><p>
        However, moments later there is a catastrophic failure and
        servers s3, s4 and s5 stop unexpectedly. A few seconds after
        this, looking again at the
        <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">replication_group_members</code></a> table on
        s1 shows that it is still online, but several others members are
        not. In fact, as seen below they are marked as
        <code class="literal">UNREACHABLE</code>. Moreover, the system could not
        reconfigure itself to change the membership, because the
        majority has been lost.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| 1999b9fb-4aaf-11e6-bb54-28b2bd168d07 | UNREACHABLE  |
| 199b2df7-4aaf-11e6-bb16-28b2bd168d07 | ONLINE       |
| 199bb88e-4aaf-11e6-babe-28b2bd168d07 | ONLINE       |
| 19ab72fc-4aaf-11e6-bb51-28b2bd168d07 | UNREACHABLE  |
| 19b33846-4aaf-11e6-ba81-28b2bd168d07 | UNREACHABLE  |
+--------------------------------------+--------------+
</pre><p>
        The table shows that s1 is now in a group that has no means of
        progressing without external intervention, because a majority of
        the servers are unreachable. In this particular case, the group
        membership list needs to be reset to allow the system to
        proceed, which is explained in this section. Alternatively, you
        could also choose to stop Group Replication on s1 and s2 (or
        stop completely s1 and s2), figure out what happened with s3, s4
        and s5 and then restart Group Replication (or the servers).
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="group-replication-unblocking-a-partition"></a>Unblocking a Partition</h4>

</div>

</div>

</div>
<p>
        Group replication enables you to reset the group membership list
        by forcing a specific configuration. For instance in the case
        above, where s1 and s2 are the only servers online, you could
        chose to force a membership configuration consisting of only s1
        and s2. This requires checking some information about s1 and s2
        and then using the
        <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
        variable.
</p>
<div class="figure">
<a name="idm140572003084656"></a><p class="title"><b>Figure 17.8 Forcing a New Membership</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-majority-lost-to-stable-group.png" width="266" height="414" alt="Three of the servers in a group, S3, S4, and S5, have failed, so the majority is lost and the group can no longer proceed without intervention. With the intervention described in the following text, S1 and S2 are able to form a stable group by themselves.">
</div>

</div>

</div>
<br class="figure-break"><p>
        Suppose that you are back in the situation where s1 and s2 are
        the only servers left in the group. Servers s3, s4 and s5 have
        left the group unexpectedly. To make servers s1 and s2 continue,
        you want to force a membership configuration that contains only
        s1 and s2.
</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Warning
</div>
<p>
          This procedure uses
          <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
          and should be considered a last resort remedy. It
          <span class="emphasis"><em>must</em></span> be used with extreme care and only
          for overriding loss of quorum. If misused, it could create an
          artificial split-brain scenario or block the entire system
          altogether.
</p>
</div>
<p>
        Recall that the system is blocked and the current configuration
        is the following (as perceived by the local failure detector on
        s1):
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| 1999b9fb-4aaf-11e6-bb54-28b2bd168d07 | UNREACHABLE  |
| 199b2df7-4aaf-11e6-bb16-28b2bd168d07 | ONLINE       |
| 199bb88e-4aaf-11e6-babe-28b2bd168d07 | ONLINE       |
| 19ab72fc-4aaf-11e6-bb51-28b2bd168d07 | UNREACHABLE  |
| 19b33846-4aaf-11e6-ba81-28b2bd168d07 | UNREACHABLE  |
+--------------------------------------+--------------+
</pre><p>
        The first thing to do is to check what is the local address
        (group communication identifier) for s1 and s2. Log in to s1 and
        s2 and get that information as follows.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT @@group_replication_local_address;</code></strong>
</pre><p>
        Once you know the group communication addresses of s1
        (<code class="literal">127.0.0.1:10000</code>) and s2
        (<code class="literal">127.0.0.1:10001</code>), you can use that on one of
        the two servers to inject a new membership configuration, thus
        overriding the existing one that has lost quorum. To do that on
        s1:
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SET GLOBAL group_replication_force_members="</code></strong>127.0.0.1:10000,127.0.0.1:10001";
</pre><p>
        This unblocks the group by forcing a different configuration.
        Check <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">replication_group_members</code></a> on
        both s1 and s2 to verify the group membership after this change.
        First on s1.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT MEMBER_ID,MEMBER_STATE FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| b5ffe505-4ab6-11e6-b04b-28b2bd168d07 | ONLINE       |
| b60907e7-4ab6-11e6-afb7-28b2bd168d07 | ONLINE       |
+--------------------------------------+--------------+
</pre><p>
        And then on s2.
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_schema.replication_group_members;</code></strong>
+--------------------------------------+--------------+
| MEMBER_ID                            | MEMBER_STATE |
+--------------------------------------+--------------+
| b5ffe505-4ab6-11e6-b04b-28b2bd168d07 | ONLINE       |
| b60907e7-4ab6-11e6-afb7-28b2bd168d07 | ONLINE       |
+--------------------------------------+--------------+
</pre><p>
        When forcing a new membership configuration, make sure that any
        servers are going to be forced out of the group are indeed
        stopped. In the scenario depicted above, if s3, s4 and s5 are
        not really unreachable but instead are online, they may have
        formed their own functional partition (they are 3 out of 5,
        hence they have the majority). In that case, forcing a group
        membership list with s1 and s2 could create an artificial
        split-brain situation. Therefore it is important before forcing
        a new membership configuration to ensure that the servers to be
        excluded are indeed shutdown and if they are not, shut them down
        before proceeding.
      </p><p>
        After you have used the
        <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
        system variable to successfully force a new group membership and
        unblock the group, ensure that you clear the system variable.
        <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
        must be empty in order to issue a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START
        GROUP_REPLICATION</code></a> statement.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-enterprise-backup"></a>17.4.4 Using MySQL Enterprise Backup with Group Replication</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572003055504"></a><a class="indexterm" name="idm140572003054112"></a><p>
      <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/" target="_top">MySQL Enterprise
      Backup</a> is a commercially-licensed backup utility for MySQL
      Server, available with
      <a class="ulink" href="https://www.mysql.com/products/enterprise/" target="_top">MySQL
      Enterprise Edition</a>. This section explains how to back up
      and subsequently restore a Group Replication member using MySQL Enterprise Backup.
      The same technique can be used to quickly add a new member to a
      group.
</p>
<h4><a name="idm140572003050672"></a>Backing up a Group Replication Member Using MySQL Enterprise Backup</h4>
<p>
      Backing up a Group Replication member is similar to backing up a
      stand-alone MySQL instance. The following instructions assume that
      you are already familiar with how to use MySQL Enterprise Backup to perform a
      backup; if that is not the case, please review the
      <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/" target="_top">MySQL
      Enterprise Backup 4.1 User's Guide</a>, especially
      <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/backing-up.html" target="_top">Backing Up a Database Server</a>. Also note the requirements described
      in <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/mysqlbackup.privileges.html" target="_top">Grant MySQL Privileges to Backup Administrator</a> and
      <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/meb-group-replication.html" target="_top">Using MySQL Enterprise Backup with Group Replication</a>.
    </p><p>
      Consider the following group with three members,
      <code class="literal">s1</code>, <code class="literal">s2</code>, and
      <code class="literal">s3</code>, running on hosts with the same names:
    </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;</code></strong>
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s1          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s3          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre><p>
      Using MySQL Enterprise Backup, create a backup of <code class="literal">s2</code> by issuing
      on its host, for example, the following command:
    </p><pre data-lang="terminal" class="programlisting">s2&gt; <strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf --backup-image=/backups/my.mbi_`date +%d%m_%H%M` \ 
		      --backup-dir=/backups/backup_`date +%d%m_%H%M` --user=root -p \
--host=127.0.0.1 backup-to-image</code></strong></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>

<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <span class="emphasis"><em>For MySQL Enterprise Backup 4.1.1 and earlier</em></span>, when
            backing up a secondary member, as MySQL Enterprise Backup cannot write backup
            status and metadata to a read-only server instance, it
            issues the following warnings during the backup operation:
          </p><pre class="programlisting">181113 21:31:08 MAIN WARNING: This backup operation cannot write to backup
progress. The MySQL server is running with the --super-read-only option.</pre><p>
            You can avoid the warning by using the
            <code class="option">--no-history-logging</code> option with your
            backup command. This is not an issue for MySQL Enterprise Backup 4.1.2 and
            later—see
            <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/meb-group-replication.html" target="_top">Using MySQL Enterprise Backup with Group Replication</a> for
            details.
</p></li></ul>
</div>

</div>
<h4><a name="group-replication-restore-failed-member"></a>Restoring a Failed Member</h4>
<p>
      Assume one of the members (<code class="literal">s3</code> in the following
      example) is irreconcilably corrupted. The most recent backup of
      group member <code class="literal">s2</code> can be used to restore
      <code class="literal">s3</code>. Here are the steps for performing the
      restore:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
          <span class="emphasis"><em>Copy the backup of s2 onto the host for
          s3.</em></span> The exact way to copy the backup depends on the
          operating system and tools available to you. In this example,
          we assume the hosts are both Linux servers and use SCP to copy
          the files between them:
        </p><pre data-lang="terminal" class="programlisting">s2/backups&gt; <strong class="userinput"><code>scp my.mbi_2206_1429 s3:/backups</code></strong></pre></li><li class="listitem"><p>
          <span class="emphasis"><em>Restore the backup.</em></span> Connect to the target
          host (the host for <code class="literal">s3</code> in this case), and
          restore the backup using MySQL Enterprise Backup. Here are the steps:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="a"><li class="listitem"><p>
              Stop the corrupted server, if it is still running. For
              example, on Linux distributions that use systemd:
            </p><pre class="programlisting">s3&gt; systemctl stop mysqld</pre></li><li class="listitem"><p>
              Preserve the configuration file
              <code class="filename">auto.cnf</code>, located in the corrupted
              server's data directory, by copying it to a safe location
              outside of the data directory. This is for preserving the
              <a class="link" href="replication.html#sysvar_server_uuid">server's UUID</a>,
              which is needed later.
            </p></li><li class="listitem"><p>
              Delete all contents in the data directory of
              <code class="literal">s3</code>. For example:
            </p><pre class="programlisting">s3&gt; rm -rf /var/lib/mysql/*</pre><p>
              If the system variables
              <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a>,
              <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir"><code class="literal">innodb_log_group_home_dir</code></a>,
              and
              <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory"><code class="literal">innodb_undo_directory</code></a>
              point to any directories other than the data directory,
              they should also be made empty; otherwise, the restore
              operation fails.
            </p></li><li class="listitem"><p>
              Restore backup of <code class="literal">s2</code> onto the host for
              <code class="literal">s3</code>:
            </p><pre data-lang="terminal" class="programlisting">s3&gt; <strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf \
  --datadir=/var/lib/mysql \
  --backup-image=/backups/my.mbi_2206_1429  \
--backup-dir=/tmp/restore_`date +%d%m_%H%M` copy-back-and-apply-log</code></strong></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
                The command above assumes that the binary logs and relay
                logs on <code class="literal">s2</code> and <code class="literal">s3</code>
                have the same base name and are at the same location on
                the two servers. If these conditions are not met, for
                MySQL Enterprise Backup 4.1.2 and later, you should use the
                <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/server-repository-options.html#option_meb_log-bin" target="_top"><code class="option">--log-bin</code></a> and
                <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/server-repository-options.html#option_meb_relay-log" target="_top"><code class="option">--relay-log</code></a> options to
                restore the binary log and relay log to their original
                file paths on <code class="literal">s3</code>. For example, if you
                know that on <code class="literal">s3</code> the binary log's base
                name is <code class="literal">s3-bin</code> and the relay-log's
                base name is <code class="literal">s3-relay-bin</code>, your
                restore command should look like:
              </p><pre data-lang="terminal" class="programlisting"><strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf \
  --datadir=/var/lib/mysql \
  --backup-image=/backups/my.mbi_2206_1429  \
  --log-bin=s3-bin --relay-log=s3-relay-bin \
  --backup-dir=/tmp/restore_`date +%d%m_%H%M` copy-back-and-apply-log</code></strong></pre><p>
                Being able to restore the binary log and relay log to
                the right file paths makes the restore process easier;
                if that is impossible for some reason, see
                <a class="xref" href="group-replication.html#group-replication-rebuild-member" title="Rebuild the Failed Member to Rejoin as a New Member">Rebuild the Failed Member to Rejoin as a New Member</a>.
</p>
</div>
</li></ol>
</div>
</li><li class="listitem"><p>
          <span class="emphasis"><em>Restore the <code class="filename">auto.cnf</code> file for
          s3.</em></span> To rejoin the replication group, the restored
          member <span class="emphasis"><em>must</em></span> have the same
          <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a> it
          used to join the group before. Supply the old server UUID by
          copying the <code class="filename">auto.cnf</code> file preserved in
          step 2 above into the data directory of the restored member.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
            If you cannot supply the failed member's original
            <a class="link" href="replication.html#sysvar_server_uuid"><code class="literal">server_uuid</code></a>
            to the restored member by restoring its old
            <code class="filename">auto.cnf</code> file, you will have to let the
            restored member join the group as a new member; see
            instructions in
            <a class="xref" href="group-replication.html#group-replication-rebuild-member" title="Rebuild the Failed Member to Rejoin as a New Member">Rebuild the Failed Member to Rejoin as a New Member</a>
            below on how to do that.
</p>
</div>
</li><li class="listitem"><p>
          <span class="emphasis"><em>Start the restored server.</em></span> For example,
          on Linux distributions that use systemd:
</p><pre class="programlisting">systemctl start mysqld</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
            If the server you are restoring is a primary member, perform
            the steps described in
            <a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="Restoring a Primary Member">Restoring a Primary Member</a>
            <span class="emphasis"><em>before starting the restored server</em></span>.
</p>
</div>
</li><li class="listitem"><p>
          <span class="emphasis"><em>Restart Group Replication.</em></span> Connect to the
          restarted <code class="literal">s3</code> using, for example, a
          <a class="link" href="programs.html#mysql" title="4.5.1 mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client, and issue the following
          command:
        </p><pre class="programlisting">mysql&gt; START GROUP_REPLICATION;</pre><p>
          Before the restored instance can become an online member of
          the group, it needs to apply any transactions that have
          happened to the group after the backup was taken; this is
          achieved using Group Replication's
          <a class="link" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5 Distributed Recovery">distributed
          recovery</a> mechanism, and the process starts after the
          <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax">START
          GROUP_REPLICATION</a> statement has been issued. To check
          the member status of the restored instance, issue:
        </p><pre class="programlisting">
mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s1          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s3          |        3306 | RECOVERING   |
+-------------+-------------+--------------+
</pre><p>
          This shows that <code class="literal">s3</code> is applying transactions
          to catch up with the group. Once it has caught up with the
          rest of the group, its <code class="literal">member_state</code> changes
          to <code class="literal">ONLINE</code>:
        </p><pre class="programlisting">
mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s1          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s3          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
            If the server you are restoring is a primary member, once it
            has gained synchrony with the group and become
            <code class="literal">ONLINE</code>, perform the steps described at
            the end of
            <a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="Restoring a Primary Member">Restoring a Primary Member</a> to
            revert the configuration changes you had made to the server
            before you started it.
</p>
</div>
</li></ol>
</div>
<p>
      The member has now been fully restored from the backup and
      functions as a regular member of the group.
</p>
<h4><a name="group-replication-rebuild-member"></a>Rebuild the Failed Member to Rejoin as a New Member</h4>
<p>
      Sometimes, the steps outlined above in
      <a class="xref" href="group-replication.html#group-replication-restore-failed-member" title="Restoring a Failed Member">Restoring a Failed Member</a>
      cannot be carried out because, for example, the binary log or
      relay log is corrupted, or it is just missing from the backup. In
      such a situation, use the backup to rebuild the member, and then
      add it to the group as a new member. In the steps below, we assume
      the rebuilt member will be named <code class="literal">s3</code>, like the
      failed member, and it will be run on the same host as
      <code class="literal">s3</code> was:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
          <span class="emphasis"><em>Copy the backup of s2 onto the host for s3
          .</em></span> The exact way to copy the backup depends on the
          operating system and tools available to you. In this example
          we assume the hosts are both Linux servers and use SCP to copy
          the files between them:
        </p><pre data-lang="terminal" class="programlisting">s2/backups&gt; <strong class="userinput"><code>scp my.mbi_2206_1429 s3:/backups</code></strong></pre></li><li class="listitem"><p>
          <span class="emphasis"><em>Restore the backup.</em></span> Connect to the target
          host (the host for <code class="literal">s3</code> in this case), and
          restore the backup using MySQL Enterprise Backup. Here are the steps:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="a"><li class="listitem"><p>
              Stop the corrupted server, if it is still running. For
              example, on Linux distributions that use systemd:
            </p><pre class="programlisting">s3&gt; systemctl stop mysqld</pre></li><li class="listitem"><p>
              Delete all contents in the data directory of
              <code class="literal">s3</code>. For example:
            </p><pre class="programlisting">s3&gt; rm -rf /var/lib/mysql/*</pre><p>
              If the system variables
              <a class="link" href="innodb-storage-engine.html#sysvar_innodb_data_home_dir"><code class="literal">innodb_data_home_dir</code></a>,
              <a class="link" href="innodb-storage-engine.html#sysvar_innodb_log_group_home_dir"><code class="literal">innodb_log_group_home_dir</code></a>,
              and
              <a class="link" href="innodb-storage-engine.html#sysvar_innodb_undo_directory"><code class="literal">innodb_undo_directory</code></a>
              point to any directories other than the data directory,
              they should also be made empty; otherwise, the restore
              operation will fail.
            </p></li><li class="listitem"><p>
              Restore the backup of <code class="literal">s2</code> onto the host
              of <code class="literal">s3</code>. With this approach, we are
              rebuilding <code class="literal"><code class="literal">s3</code></code> as a
              new member, for which we do not need or do not want to use
              the old binary and relay logs in the backup; therefore, if
              these logs have been included in your backup, exclude them
              using the
              <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/backup-capacity-options.html#option_meb_skip-binlog" target="_top"><code class="option">--skip-binlog</code></a>
              and <a class="ulink" href="https://dev.mysql.com/doc/mysql-enterprise-backup/4.1/en/backup-capacity-options.html#option_meb_skip-relaylog" target="_top"><code class="option">--skip-relaylog</code></a> options:
            </p><pre data-lang="terminal" class="programlisting">s3&gt; <strong class="userinput"><code>mysqlbackup --defaults-file=/etc/my.cnf \
  --datadir=/var/lib/mysql \
  --backup-image=/backups/my.mbi_2206_1429  \
  --backup-dir=/tmp/restore_`date +%d%m_%H%M` \
  --skip-binlog --skip-relaylog \
copy-back-and-apply-log</code></strong></pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Notes
</div>

<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    If you have healthy binary log and relay logs in the
                    backup that you can transfer onto the target host
                    with no issues, you are recommended to follow the
                    easier procedure as described in
                    <a class="xref" href="group-replication.html#group-replication-restore-failed-member" title="Restoring a Failed Member">Restoring a Failed Member</a>
                    above.
                  </p></li><li class="listitem"><p>
                    Do NOT restore manually the corrupted server's
                    <code class="filename">auto.cnf</code> file to the data
                    directory of the new member—when the rebuilt
                    <code class="literal">s3</code> joins the group as a new
                    member, it is going to be assigned a new server
                    UUID.
</p></li></ul>
</div>

</div>
</li></ol>
</div>
</li><li class="listitem"><p>
          <span class="emphasis"><em>Start the restored server.</em></span> For example,
          on Linux distributions that use systemd:
</p><pre class="programlisting">systemctl start mysqld</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
            If the server you are restoring is a primary member, perform
            the steps described in
            <a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="Restoring a Primary Member">Restoring a Primary Member</a>
            <span class="emphasis"><em>before starting the restored server</em></span>.
</p>
</div>
</li><li class="listitem"><p>
          <span class="emphasis"><em>Reconfigure the restored member to join Group
          Replication.</em></span> Connect to the restored server with a
          <a class="link" href="programs.html#mysql" title="4.5.1 mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client and reset the master and slave
          information with the following commands:
        </p><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>RESET MASTER;</code></strong></pre><pre data-lang="sql" class="programlisting">mysql&gt; <strong class="userinput"><code>RESET SLAVE ALL;</code></strong></pre><p>
          For the restored server to be able to recover automatically
          using Group Replication's built-in mechanism for
          <a class="link" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5 Distributed Recovery">distributed
          recovery</a>, configure the server's
          <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a> variable. To do
          this, use the <code class="filename">backup_gtid_executed.sql</code>
          file included in the backup of <code class="literal">s2</code>, which is
          usually restored under the restored member's data directory.
          Disable binary logging, use the
          <code class="filename">backup_gtid_executed.sql</code> file to
          configure <a class="link" href="replication.html#sysvar_gtid_executed"><code class="literal">gtid_executed</code></a>, and
          then re-enable binary logging by issuing the following
          statements with your <a class="link" href="programs.html#mysql" title="4.5.1 mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client:
        </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SET SQL_LOG_BIN=OFF;</code></strong>
mysql&gt; <strong class="userinput"><code>SOURCE <em class="replaceable"><code>datadir</code></em>/backup_gtid_executed.sql</code></strong>
mysql&gt; <strong class="userinput"><code>SET SQL_LOG_BIN=ON;</code></strong>
</pre><p>
          Then, configure the
          <a class="link" href="group-replication.html#group-replication-user-credentials" title="17.2.1.3 User Credentials">Group
          Replication user credentials</a> on the member:
        </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>CHANGE MASTER TO MASTER_USER='<em class="replaceable"><code>rpl_user</code></em>', MASTER_PASSWORD='<em class="replaceable"><code>password</code></em>' / 
		FOR CHANNEL 'group_replication_recovery';</code></strong></pre></li><li class="listitem"><p>
          <span class="emphasis"><em>Restart Group Replication.</em></span> Issue the
          following command to the restored server with your
          <a class="link" href="programs.html#mysql" title="4.5.1 mysql — The MySQL Command-Line Client"><span class="command"><strong>mysql</strong></span></a> client:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>START GROUP_REPLICATION;</code></strong></pre><p>
          Before the restored instance can become an online member of
          the group, it needs to apply any transactions that have
          happened to the group after the backup was taken; this is
          achieved using Group Replication's
          <a class="link" href="group-replication.html#group-replication-distributed-recovery" title="17.9.5 Distributed Recovery">distributed
          recovery</a> mechanism, and the process starts after the
          <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax">START
          GROUP_REPLICATION</a> statement has been issued. To check
          the member status of the restored instance, issue:
        </p><pre class="programlisting">
mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s3          |        3306 | RECOVERING   |
| s2          |        3306 | ONLINE       |
| s1          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre><p>
          This shows that <code class="literal">s3</code> is applying transactions
          to catch up with the group. Once it has caught up with the
          rest of the group, its <code class="literal">member_state</code> changes
          to <code class="literal">ONLINE</code>:
        </p><pre class="programlisting">
mysql&gt; SELECT member_host, member_port, member_state FROM performance_schema.replication_group_members;
+-------------+-------------+--------------+
| member_host | member_port | member_state |
+-------------+-------------+--------------+
| s3          |        3306 | ONLINE       |
| s2          |        3306 | ONLINE       |
| s1          |        3306 | ONLINE       |
+-------------+-------------+--------------+
</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
            If the server you are restoring is a primary member, once it
            has gained synchrony with the group and become
            <code class="literal">ONLINE</code>, perform the steps described at
            the end of
            <a class="xref" href="group-replication.html#group-replication-meb-restore-primary" title="Restoring a Primary Member">Restoring a Primary Member</a> to
            revert the configuration changes you had made to the server
            before you started it.
</p>
</div>
</li></ol>
</div>
<p>
      The member has now been restored to the group as a new member.
    </p><p><a name="group-replication-meb-restore-primary"></a><b>Restoring a Primary Member. </b>
        If the restored member is a primary in the group, care must be
        taken to prevent writes to the restored database during the
        Group Replication recovery phase: Depending on how the group is
        accessed by clients, there is a possibility of DML statements
        being executed on the restored member once it becomes accessible
        on the network, prior to the member finishing its catch-up on
        the activities it has missed while off the group. To avoid this,
        <span class="emphasis"><em>before starting the restored server</em></span>,
        configure the following system variables in the server option
        file:
      </p><pre data-lang="ini" class="programlisting">
group_replication_start_on_boot=OFF
super_read_only=ON
event_scheduler=OFF
</pre><p>
      These settings ensure that the member becomes read-only at startup
      and that the event scheduler is turned off while the member is
      catching up with the group during the recovery phase. Adequate
      error handling must also be configured on the clients, as they
      will be prevented temporarily from performing DML operations
      during this period on the restored member. Once the restore
      process is fully completed and the restored member is in-sync with
      the rest of the group, revert those changes; restart the event
      scheduler:
    </p><pre data-lang="sql" class="programlisting">
mysql&gt; <strong class="userinput"><code>SET global event_scheduler=ON;</code></strong>
</pre><p>
      Edit the following system variables in the member's option
      file, so things are correctly configured for the next startup:
    </p><pre data-lang="ini" class="programlisting">
group_replication_start_on_boot=ON
super_read_only=OFF
event_scheduler=ON</pre>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="group-replication-security"></a>17.5 Group Replication Security</h2>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-ip-address-whitelisting">17.5.1 Group Replication IP Address Whitelisting</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-secure-socket-layer-support-ssl">17.5.2 Group Replication Secure Socket Layer (SSL) Support</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-virtual-private-networks-vpn">17.5.3 Group Replication and Virtual Private Networks (VPNs)</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572002904896"></a><p>
    This section explains how to secure a group, securing the
    connections between members of a group, or by establishing a
    security perimeter using IP address whitelisting.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-ip-address-whitelisting"></a>17.5.1 Group Replication IP Address Whitelisting</h3>
</div>
</div>
</div>
<a class="indexterm" name="idm140572002902032"></a><a class="indexterm" name="idm140572002900640"></a><a class="indexterm" name="idm140572002899248"></a><p>
      The Group Replication plugin has a configuration option to
      determine from which hosts an incoming Group Communication System
      connection can be accepted. This option is called
      <a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist"><code class="literal">group_replication_ip_whitelist</code></a>.
      If you set this option on a server s1, then when server s2 is
      establishing a connection to s1 for the purpose of engaging group
      communication, s1 first checks the whitelist before accepting the
      connection from s2. If s2 is in the whitelist, then s1 accepts the
      connection, otherwise s1 rejects the connection attempt by s2.
    </p><p>
      If you do not specify a whitelist explicitly, the group
      communication engine (XCom) automatically scans active interfaces
      on the host, and identifies those with addresses on private
      subnetworks. These addresses and the <code class="literal">localhost</code>
      IP address for IPv4 are used to create an automatic Group
      Replication whitelist. The automatic whitelist therefore includes
      any IP addresses found for the host in the following ranges:
    </p><pre data-lang="none" class="programlisting">
10/8 prefix       (10.0.0.0 - 10.255.255.255) - Class A 
172.16/12 prefix  (172.16.0.0 - 172.31.255.255) - Class B
192.168/16 prefix (192.168.0.0 - 192.168.255.255) - Class C
127.0.0.1 - localhost for IPv4</pre><p>
      An entry is added to the error log stating the addresses that have
      been whitelisted automatically for the host.
    </p><p>
      The automatic whitelist of private addresses cannot be used for
      connections from servers outside the private network, so a server,
      even if it has interfaces on public IPs, does not by default allow
      Group Replication connections from external hosts. For Group
      Replication connections between server instances that are on
      different machines, you must provide public IP addresses and
      specify these as an explicit whitelist. If you specify any entries
      for the whitelist, the private and <code class="literal">localhost</code>
      addresses are not added automatically, so if you use any of these,
      you must specify them explicitly.
    </p><p>
      To specify a whitelist manually, use the
      <a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist"><code class="literal">group_replication_ip_whitelist</code></a>
      option. You cannot change the whitelist on a server while it is an
      active member of a replication group. If the member is active, you
      must issue a <a class="link" href="sql-syntax.html#stop-group-replication" title="13.4.3.2 STOP GROUP_REPLICATION Syntax"><code class="literal">STOP GROUP_REPLICATION</code></a>
      statement before changing the whitelist, and a
      <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START GROUP_REPLICATION</code></a> statement
      afterwards.
    </p><p>
      In the whitelist, you can specify any combination of the
      following:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          IPv4 addresses (for example, <code class="literal">198.51.100.44</code>)
        </p></li><li class="listitem"><p>
          IPv4 addresses with CIDR notation (for example,
          <code class="literal">192.0.2.21/24</code>)
        </p></li><li class="listitem"><p>
          Host names, from MySQL 5.7.21 (for example,
          <code class="literal">example.org</code>)
        </p></li><li class="listitem"><p>
          Host names with CIDR notation, from MySQL 5.7.21 (for example,
          <code class="literal">www.example.com/24</code>)
</p></li></ul>
</div>
<p>
      IPv6 addresses, and host names that resolve to IPv6 addresses, are
      not supported in MySQL 5.7. You can use CIDR notation in
      combination with host names or IP addresses to whitelist a block
      of IP addresses with a particular network prefix, but do ensure
      that all the IP addresses in the specified subnet are under your
      control.
    </p><p>
      You must stop and restart Group Replication on a member in order
      to change its whitelist. A comma must separate each entry in the
      whitelist. For example:
    </p><pre data-lang="sql" class="programlisting">
mysql&gt; STOP GROUP_REPLICATION;
mysql&gt; SET GLOBAL group_replication_ip_whitelist="192.0.2.21/24,198.51.100.44,203.0.113.0/24,example.org,www.example.com/24";
mysql&gt; START GROUP_REPLICATION;</pre><p>
      The whitelist must contain the IP address or host name that is
      specified in each member's
      <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
      system variable. This address is not the same as the MySQL server
      SQL protocol host and port, and is not specified in the
      <a class="link" href="server-administration.html#sysvar_bind_address"><code class="literal">bind_address</code></a> system variable for
      the server instance.
    </p><p>
      When a replication group is reconfigured (for example, when a new
      primary is elected or a member joins or leaves), the group members
      re-establish connections between themselves. If a group member is
      only whitelisted by servers that are no longer part of the
      replication group after the reconfiguration, it is unable to
      reconnect to the remaining servers in the replication group that
      do not whitelist it. To avoid this scenario entirely, specify the
      same whitelist for all servers that are members of the replication
      group.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
        It is possible to configure different whitelists on different
        group members according to your security requirements, for
        example, in order to keep different subnets separate. If you
        need to configure different whitelists to meet your security
        requirements, ensure that there is sufficient overlap between
        the whitelists in the replication group to maximize the
        possibility of servers being able to reconnect in the absence of
        their original seed member.
</p>
</div>
<p>
      For host names, name resolution takes place only when a connection
      request is made by another server. A host name that cannot be
      resolved is not considered for whitelist validation, and a warning
      message is written to the error log. Forward-confirmed reverse DNS
      (FCrDNS) verification is carried out for resolved host names.
</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Warning
</div>
<p>
        Host names are inherently less secure than IP addresses in a
        whitelist. FCrDNS verification provides a good level of
        protection, but can be compromised by certain types of attack.
        Specify host names in your whitelist only when strictly
        necessary, and ensure that all components used for name
        resolution, such as DNS servers, are maintained under your
        control. You can also implement name resolution locally using
        the hosts file, to avoid the use of external components.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-secure-socket-layer-support-ssl"></a>17.5.2 Group Replication Secure Socket Layer (SSL) Support</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572002869536"></a><a class="indexterm" name="idm140572002868144"></a><p>
      Group communication connections as well as recovery connections,
      are secured using SSL. The following sections explain how to
      configure connections.
</p>
<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h4 class="title"><a name="group-replication-configuring-ssl-for-recovery"></a>Configuring SSL for Group Replication Recovery</h4>
</div>
</div>
</div>
<p>
        Recovery is performed through a regular asynchronous replication
        connection. Once the donor is selected, the server joining the
        group establishes an asynchronous replication connection. This
        is all automatic.
      </p><p>
        However, a user that requires an SSL connection must have been
        created before the server joining the group connects to the
        donor. Typically, this is set up at the time one is provisioning
        a server to join the group.
      </p><pre data-lang="sql" class="programlisting">
donor&gt; SET SQL_LOG_BIN=0;
donor&gt; CREATE USER 'rec_ssl_user'@'%' REQUIRE SSL;
donor&gt; GRANT replication slave ON *.* TO 'rec_ssl_user'@'%';
donor&gt; SET SQL_LOG_BIN=1;</pre><p>
        Assuming that all servers already in the group have a
        replication user set up to use SSL, you configure the server
        joining the group to use those credentials when connecting to
        the donor. That is done according to the values of the SSL
        options provided for the Group Replication plugin.
      </p><pre data-lang="sql" class="programlisting">
new_member&gt; SET GLOBAL group_replication_recovery_use_ssl=1;
new_member&gt; SET GLOBAL group_replication_recovery_ssl_ca= '.../cacert.pem';
new_member&gt; SET GLOBAL group_replication_recovery_ssl_cert= '.../client-cert.pem';
new_member&gt; SET GLOBAL group_replication_recovery_ssl_key= '.../client-key.pem';</pre><p>
        And by configuring the recovery channel to use the credentials
        of the user that requires an SSL connection.
      </p><pre data-lang="sql" class="programlisting">
new_member&gt; CHANGE MASTER TO MASTER_USER="rec_ssl_user" FOR CHANNEL "group_replication_recovery";
new_member&gt; START GROUP_REPLICATION;</pre>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="group-replication-configuring-ssl-for-group-communication"></a>Configuring SSL for Group Communication</h4>

</div>

</div>

</div>
<p>
        Secure sockets can be used to establish communication between
        members in a group. The configuration for this depends on the
        server's SSL configuration. As such, if the server has SSL
        configured, the Group Replication plugin also has SSL
        configured. For more information on the options for configuring
        the server SSL, see
        <a class="xref" href="programs.html#encrypted-connection-options" title="Command Options for Encrypted Connections">Command Options for Encrypted Connections</a>. The options
        which configure Group Replication are shown in the following
        table.
</p>
<div class="table">
<a name="idm140572002856416"></a><p class="title"><b>Table 17.2 SSL Options</b></p>
<div class="table-contents">
<table summary="Lists the server configuration options for SSL and describes their effect on the configuration of the Group Replication plugin for SSL."><col width="0.43%"><col width="0.57%"><thead><tr>
            <th scope="col"><p>
                Server Configuration
              </p></th>
            <th scope="col"><p>
                Plugin Configuration Description
              </p></th>
          </tr></thead><tbody><tr>
            <td scope="row"><p>
                ssl_key
              </p></td>
            <td><p>
                Path of key file. To be used as client and server
                certificate.
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                ssl_cert
              </p></td>
            <td><p>
                Path of certificate file. To be used as client and
                server certificate.
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                ssl_ca
              </p></td>
            <td><p>
                Path of file with SSL Certificate Authorities that are
                trusted.
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                ssl_capath
              </p></td>
            <td><p>
                Path of directory containing certificates for SSL
                Certificate Authorities that are trusted.
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                ssl_crl
              </p></td>
            <td><p>
                Path of file containing the certificate revocation
                lists.
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                ssl_crlpath
              </p></td>
            <td><p>
                Path of directory containing revoked certificate lists.
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                ssl_cipher
              </p></td>
            <td><p>
                Permitted ciphers to use while encrypting data over the
                connection.
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                tls_version
              </p></td>
            <td><p>
                Secure communication will use this version and its
                protocols.
              </p></td>
</tr></tbody></table>
</div>

</div>
<br class="table-break"><p>
        These options are MySQL Server configuration options which Group
        Replication relies on for its configuration. In addition there
        is the following Group Replication specific option to configure
        SSL on the plugin itself.
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            <a class="link" href="group-replication.html#sysvar_group_replication_ssl_mode"><code class="literal">group_replication_ssl_mode</code></a>
            - specifies the security state of the connection between
            Group Replication members.
</p></li></ul>
</div>

<div class="table">
<a name="idm140572002825360"></a><p class="title"><b>Table 17.3 group_replication_ssl_mode configuration values</b></p>
<div class="table-contents">
<table summary="Lists the possible values for group_replication_ssl_mode and describes their effect on how replication group members connect to each other."><col width="0.43%"><col width="0.57%"><thead><tr>
            <th scope="col"><p>
                Value
              </p></th>
            <th scope="col"><p>
                Description
              </p></th>
          </tr></thead><tbody><tr>
            <td scope="row"><p>
                <span class="emphasis"><em>DISABLED</em></span>
              </p></td>
            <td><p>
                Establish an unencrypted connection
                (<span class="emphasis"><em>default</em></span>).
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                REQUIRED
              </p></td>
            <td><p>
                Establish a secure connection if the server supports
                secure connections.
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                VERIFY_CA
              </p></td>
            <td><p>
                Like REQUIRED, but additionally verify the server TLS
                certificate against the configured Certificate Authority
                (CA) certificates.
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                VERIFY_IDENTITY
              </p></td>
            <td><p>
                Like VERIFY_CA, but additionally verify that the server
                certificate matches the host to which the connection is
                attempted.
              </p></td>
</tr></tbody></table>
</div>

</div>
<br class="table-break"><p>
        The following example shows an example my.cnf file section used
        to configure SSL on a server and how activate it for Group
        Replication.
      </p><pre data-lang="ini" class="programlisting">
[mysqld]
ssl_ca = "cacert.pem"
ssl_capath = "/.../ca_directory"
ssl_cert = "server-cert.pem"
ssl_cipher = "DHE-RSA-AEs256-SHA"
ssl_crl = "crl-server-revoked.crl"
ssl_crlpath = "/.../crl_directory"
ssl_key = "server-key.pem"
group_replication_ssl_mode= REQUIRED</pre><p>
        The only plugin specific configuration option that is listed is
        <a class="link" href="group-replication.html#sysvar_group_replication_ssl_mode"><code class="literal">group_replication_ssl_mode</code></a>.
        This option activates the SSL communication between members of
        the group, by configuring the SSL framework with the
        <code class="literal">ssl_*</code> parameters that are provided to the
        server.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-virtual-private-networks-vpn"></a>17.5.3 Group Replication and Virtual Private Networks (VPNs)</h3>

</div>

</div>

</div>
<p>
      

      There is nothing preventing Group Replication from operating over
      a virtual private network. At its core, it just relies on an IPv4
      socket to establish connections between servers for the purpose of
      propagating messages between them.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="group-replication-options"></a>17.6 Group Replication System Variables</h2>

</div>

</div>

</div>
<a class="indexterm" name="idm140572002799520"></a><p>
    This section lists the system variables that are specific to the
    Group Replication plugin. Every configuration option is prefixed
    with "<code class="literal">group_replication</code>".
  </p><p>
    Most system variables for Group Replication are described as
    dynamic, and their values can be changed while the server is
    running. However, in most cases, the change only takes effect after
    you stop and restart Group Replication on the group member using a
    <a class="link" href="sql-syntax.html#stop-group-replication" title="13.4.3.2 STOP GROUP_REPLICATION Syntax"><code class="literal">STOP GROUP_REPLICATION</code></a> statement
    followed by a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START GROUP_REPLICATION</code></a>
    statement. Changes to the following system variables take effect
    without stopping and restarting Group Replication:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_applier_threshold"><code class="literal">group_replication_flow_control_applier_threshold</code></a>
      </p></li><li class="listitem"><p>
        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_certifier_threshold"><code class="literal">group_replication_flow_control_certifier_threshold</code></a>
      </p></li><li class="listitem"><p>
        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_mode"><code class="literal">group_replication_flow_control_mode</code></a>
</p></li></ul>
</div>
<p>
    Most system variables for Group Replication can have different
    values on different group members. For the following system
    variables, it is advisable to set the same value on all members of a
    group in order to avoid unnecessary rollback of transactions,
    failure of message delivery, or failure of message recovery:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="group-replication.html#sysvar_group_replication_auto_increment_increment"><code class="literal">group_replication_auto_increment_increment</code></a>
      </p></li><li class="listitem"><p>
        <a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold"><code class="literal">group_replication_compression_threshold</code></a>
      </p></li><li class="listitem"><p>
        <a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit"><code class="literal">group_replication_transaction_size_limit</code></a>
</p></li></ul>
</div>
<p>
    Some system variables on a Group Replication group member, including
    some Group Replication-specific system variables and some general
    system variables, are group-wide configuration settings. These
    system variables must have the same value on all group members,
    cannot be changed while Group Replication is running, and require a
    full reboot of the group (a bootstrap by a server with
    <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group=ON</code></a>)
    in order for the value change to take effect. These conditions apply
    to the following system variables:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode"><code class="literal">group_replication_single_primary_mode</code></a>
      </p></li><li class="listitem"><p>
        <a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks"><code class="literal">group_replication_enforce_update_everywhere_checks</code></a>
      </p></li><li class="listitem"><p>
        <a class="link" href="group-replication.html#sysvar_group_replication_gtid_assignment_block_size"><code class="literal">group_replication_gtid_assignment_block_size</code></a>
      </p></li><li class="listitem"><p>
        <a class="ulink" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_default_table_encryption" target="_top"><code class="literal">default_table_encryption</code></a>
      </p></li><li class="listitem"><p>
        <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a>
      </p></li><li class="listitem"><p>
        <a class="link" href="replication.html#sysvar_transaction_write_set_extraction"><code class="literal">transaction_write_set_extraction</code></a>
</p></li></ul>
</div>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">
<div class="admon-title">
Important
</div>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          A number of system variables for Group Replication are not
          completely validated during server startup if they are passed
          as command line arguments to the server. These system
          variables include
          <a class="link" href="group-replication.html#sysvar_group_replication_group_name"><code class="literal">group_replication_group_name</code></a>,
          <a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode"><code class="literal">group_replication_single_primary_mode</code></a>,
          <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>,
          the SSL variables, and the flow control system variables. They
          are only fully validated after the server has started.
        </p></li><li class="listitem"><p>
          System variables for Group Replication that specify IP
          addresses or host names for group members are not validated
          until a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START GROUP_REPLICATION</code></a>
          statement is issued. Group Replication's Group Communication
          System (GCS) is not available to validate the values until
          that point.
</p></li></ul>
</div>

</div>
<p>
    The system variables that are specific to the Group Replication
    plugin are as follows:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a name="sysvar_group_replication_allow_local_disjoint_gtids_join"></a>
        <a class="indexterm" name="idm140572002759984"></a>

        <a class="indexterm" name="idm140572002758976"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_allow_local_disjoint_gtids_join"><code class="literal">group_replication_allow_local_disjoint_gtids_join</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_allow_local_disjoint_gtids_join"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-allow-local-disjoint-gtids-join[={OFF|ON}]</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>Deprecated</strong></span></td>
<td>5.7.21</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_allow_local_disjoint_gtids_join">group_replication_allow_local_disjoint_gtids_join</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Boolean</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">OFF</code></td>
</tr></tbody></table>
</div>
<p>
        Deprecated in version 5.7.21 and scheduled for removal in a
        future version. Allows the server to join the group even if it
        has local transactions that are not present in the group.
</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Warning
</div>
<p>
          Use caution when enabling this option as incorrect usage can
          lead to conflicts in the group and rollback of transactions.
          The option should only be enabled as a last resort method to
          allow a server that has local transactions to join an existing
          group, and then only if the local transactions do not affect
          the data that is handled by the group (for example, an
          administrative action that was written to the binary log). The
          option should not be left enabled on all group members.
</p>
</div>
</li><li class="listitem"><p><a name="sysvar_group_replication_allow_local_lower_version_join"></a>
        <a class="indexterm" name="idm140572002725040"></a>

        <a class="indexterm" name="idm140572002724032"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_allow_local_lower_version_join"><code class="literal">group_replication_allow_local_lower_version_join</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_allow_local_lower_version_join"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-allow-local-lower-version-join[={OFF|ON}]</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_allow_local_lower_version_join">group_replication_allow_local_lower_version_join</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Boolean</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">OFF</code></td>
</tr></tbody></table>
</div>
<p>
        Allows the current server to join the group even if it has a
        lower major version than the group. With the default setting
        <code class="literal">OFF</code>, servers are not permitted to join a
        replication group if they have a lower major version than the
        existing group members. For example, a MySQL 5.7 server cannot
        join a group that consists of MySQL 8.0 servers. This standard
        policy ensures that all members of a group are able to exchange
        messages and apply transactions. Set
        <a class="link" href="group-replication.html#sysvar_group_replication_allow_local_lower_version_join"><code class="literal">group_replication_allow_local_lower_version_join</code></a>
        to <code class="literal">ON</code> only in the following scenarios:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            A server must be added to the group in an emergency in order
            to improve the group's fault tolerance, and only older
            versions are available.
          </p></li><li class="listitem"><p>
            You want to carry out a downgrade of the replication group
            members without shutting down the whole group and
            bootstrapping it again.
</p></li></ul>
</div>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<div class="admon-title">
Warning
</div>
<p>
          Setting this option to <code class="literal">ON</code> does not make the
          new member compatible with the group, and allows it to join
          the group without any safeguards against incompatible
          behaviors by the existing members. To ensure the new member's
          correct operation, take <span class="emphasis"><em>both</em></span> of the
          following precautions:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
              Before the server with the lower major version joins the
              group, stop all writes on that server.
            </p></li><li class="listitem"><p>
              From the point where the server with the lower major
              version joins the group, stop all writes on the other
              servers in the group.
</p></li></ol>
</div>
<p>
          Without these precautions, the server with the lower major
          version is likely to experience difficulties and terminate
          with an error.
</p>
</div>
</li><li class="listitem"><p><a name="sysvar_group_replication_auto_increment_increment"></a>
        <a class="indexterm" name="idm140572002684176"></a>

        <a class="indexterm" name="idm140572002683088"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_auto_increment_increment"><code class="literal">group_replication_auto_increment_increment</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_auto_increment_increment"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-auto-increment-increment=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_auto_increment_increment">group_replication_auto_increment_increment</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">7</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">1</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">65535</code></td>
</tr></tbody></table>
</div>
<p>
        Determines the interval between successive column values for
        transactions that execute on this server instance. This system
        variable should have the same value on all group members. When
        Group Replication is started on a server, the value of the
        server system variable
        <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> is
        changed to this value, and the value of the server system
        variable <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a>
        is changed to the server ID. These settings avoid the selection
        of duplicate auto-increment values for writes on group members,
        which causes rollback of transactions. The changes are reverted
        when Group Replication is stopped. These changes are only made
        and reverted if
        <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> and
        <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a> each have
        their default value of 1. If their values have already been
        modified from the default, Group Replication does not alter
        them. From MySQL 8.0, the system variables are also not modified
        when Group Replication is in single-primary mode, where only one
        server writes.
      </p><p>
        The default value of 7 represents a balance between the number
        of usable values and the permitted maximum size of a replication
        group (9 members). If your group has more or fewer members, you
        can set this system variable to match the expected number of
        group members before Group Replication is started. You cannot
        change the setting while Group Replication is running.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_bootstrap_group"></a>
        <a class="indexterm" name="idm140572002641984"></a>

        <a class="indexterm" name="idm140572002640976"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_bootstrap_group"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-bootstrap-group[={OFF|ON}]</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group">group_replication_bootstrap_group</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Boolean</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">OFF</code></td>
</tr></tbody></table>
</div>
<p>
        Configure this server to bootstrap the group. This option must
        only be set on one server and only when starting the group for
        the first time or restarting the entire group. After the group
        has been bootstrapped, set this option to
        <code class="literal">OFF</code>. It should be set to
        <code class="literal">OFF</code> both dynamically and in the configuration
        files. Starting two servers or restarting one server with this
        option set while the group is running may lead to an artificial
        split brain situation, where two independent groups with the
        same name are bootstrapped.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_components_stop_timeout"></a>
        <a class="indexterm" name="idm140572002609920"></a>

        <a class="indexterm" name="idm140572002608832"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_components_stop_timeout"><code class="literal">group_replication_components_stop_timeout</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_components_stop_timeout"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-components-stop-timeout=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_components_stop_timeout">group_replication_components_stop_timeout</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">31536000</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">2</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">31536000</code></td>
</tr></tbody></table>
</div>
<p>
        Timeout, in seconds, that Group Replication waits for each of
        the components when shutting down.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_compression_threshold"></a>
        <a class="indexterm" name="idm140572002573488"></a>

        <a class="indexterm" name="idm140572002572480"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold"><code class="literal">group_replication_compression_threshold</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_compression_threshold"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-compression-threshold=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold">group_replication_compression_threshold</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">1000000</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table>
</div>
<p>
        The value in bytes above which (LZ4) compression is enforced.
        When set to zero, deactivates compression. The value of
        <a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold"><code class="literal">group_replication_compression_threshold</code></a>
        should be the same on all group members.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_enforce_update_everywhere_checks"></a>
        <a class="indexterm" name="idm140572002535888"></a>

        <a class="indexterm" name="idm140572002534880"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks"><code class="literal">group_replication_enforce_update_everywhere_checks</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_enforce_update_everywhere_checks"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-enforce-update-everywhere-checks[={OFF|ON}]</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks">group_replication_enforce_update_everywhere_checks</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Boolean</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">OFF</code></td>
</tr></tbody></table>
</div>
<p>
        Enable or disable strict consistency checks for multi-primary
        update everywhere. The default is that checks are disabled. In
        single-primary mode, this option must be disabled on all group
        members. In multi-primary mode, when this option is enabled,
        statements are checked as follows to ensure they are compatible
        with multi-primary mode:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            If a transaction is executed under the
            <code class="literal">SERIALIZABLE</code> isolation level, then its
            commit fails when synchronizing itself with the group.
          </p></li><li class="listitem"><p>
            If a transaction executes against a table that has foreign
            keys with cascading constraints, then the transaction fails
            to commit when synchronizing itself with the group.
</p></li></ul>
</div>
<p>
        This system variable is a group-wide configuration setting. It
        must have the same value on all group members, cannot be changed
        while Group Replication is running, and requires a full reboot
        of the group (a bootstrap by a server with
        <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group=ON</code></a>)
        in order for the value change to take effect.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_exit_state_action"></a>
        <a class="indexterm" name="idm140572002500048"></a>

        <a class="indexterm" name="idm140572002499040"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action"><code class="literal">group_replication_exit_state_action</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_exit_state_action"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-exit-state-action=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.24</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action">group_replication_exit_state_action</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Enumeration</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">READ_ONLY</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
<td><p class="valid-value"><code class="literal">ABORT_SERVER</code></p><p class="valid-value"><code class="literal">READ_ONLY</code></p></td>
</tr></tbody></table>
</div>
<p>
        Configures how Group Replication behaves when a server instance
        leaves the group unintentionally, for example after encountering
        an applier error, or in the case of a loss of majority, or when
        another member of the group expels it due to a suspicion timing
        out. The timeout period for a member to leave the group in the
        case of a loss of majority is set by the
        <a class="link" href="group-replication.html#sysvar_group_replication_unreachable_majority_timeout"><code class="literal">group_replication_unreachable_majority_timeout</code></a>
        system variable. Note that an expelled group member does not
        know that it was expelled until it reconnects to the group, so
        the specified action is only taken if the member manages to
        reconnect, or if the member raises a suspicion on itself and
        expels itself.
      </p></li><li class="listitem"><p>
        When
        <a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action"><code class="literal">group_replication_exit_state_action</code></a>
        is set to <code class="literal">ABORT_SERVER</code>, if the member exits
        the group unintentionally, the instance shuts down MySQL.
      </p><p>
        When
        <a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action"><code class="literal">group_replication_exit_state_action</code></a>
        is set to <code class="literal">READ_ONLY</code>, if the member exits the
        group unintentionally, the instance switches MySQL to super read
        only mode (by setting the system variable
        <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> to
        <code class="literal">ON</code>). This setting is the default in MySQL
        5.7.
</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p>
          If a failure occurs before the member has successfully joined
          the group, the specified exit action <span class="emphasis"><em>is not
          taken</em></span>. This is the case if there is a failure
          during the local configuration check, or a mismatch between
          the configuration of the joining member and the configuration
          of the group. In these situations, the
          <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> system
          variable is left with its original value, and the server does
          not shut down MySQL. To ensure that the server cannot accept
          updates when Group Replication did not start, we therefore
          recommend that
          <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only=ON</code></a> is set in
          the server's configuration file at startup, which Group
          Replication will change to <code class="literal">OFF</code> on primary
          members after it has been started successfully. This safeguard
          is particularly important when the server is configured to
          start Group Replication on server boot
          (<a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot"><code class="literal">group_replication_start_on_boot=ON</code></a>),
          but it is also useful when Group Replication is started
          manually using a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START
          GROUP_REPLICATION</code></a> command.
        </p><p>
          If a failure occurs after the member has successfully joined
          the group, the specified exit action <span class="emphasis"><em>is
          taken</em></span>. This is the case if there is an applier
          error, if the member is expelled from the group, or if the
          member is set to time out in the event of an unreachable
          majority. In these situations, if <code class="literal">READ_ONLY</code>
          is the exit action, the
          <a class="link" href="server-administration.html#sysvar_super_read_only"><code class="literal">super_read_only</code></a> system
          variable is set to <code class="literal">ON</code>, or if
          <code class="literal">ABORT_SERVER</code> is the exit action, the server
          shuts down MySQL.
</p>
</div>

<div class="table">
<a name="idm140572002447456"></a><p class="title"><b>Table 17.4 Exit actions in Group Replication failure situations</b></p>
<div class="table-contents">
<table frame="all" summary="Summarizes how the selected exit action does or does not operate depending on the failure situation"><col width="33%" align="left"><col width="33%" align="left"><col width="33%" align="left"><thead><tr>
            <th scope="col"><p>
                Failure situation
              </p></th>
            <th scope="col"><p>
                Group Replication started with <code class="literal">START
                GROUP_REPLICATION</code>
              </p></th>
            <th scope="col"><p>
                Group Replication started with
                <code class="literal">group_replication_start_on_boot =ON</code>
              </p></th>
          </tr></thead><tbody><tr>
            <td scope="row"><p>
                Member fails local configuration check
              </p><p>
                OR
              </p><p>
                Mismatch between joining member and group configuration
              </p></td>
            <td><p>
                <code class="literal">super_read_only</code> unchanged
              </p><p>
                MySQL continues running
              </p><p>
                Set <code class="literal">super_read_only=ON</code> at startup to
                prevent updates
              </p></td>
            <td><p>
                <code class="literal">super_read_only</code> unchanged
              </p><p>
                MySQL continues running
              </p><p>
                Set <code class="literal">super_read_only=ON</code> at startup to
                prevent updates (Important)
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                Applier error on member
              </p><p>
                OR
              </p><p>
                Member expelled from group
              </p><p>
                OR
              </p><p>
                Unreachable majority timeout
              </p></td>
            <td><p>
                <code class="literal">super_read_only</code> set to
                <code class="literal">ON</code>
              </p><p>
                OR
              </p><p>
                MySQL shuts down
              </p></td>
            <td><p>
                <code class="literal">super_read_only</code> set to
                <code class="literal">ON</code>
              </p><p>
                OR
              </p><p>
                MySQL shuts down
              </p></td>
</tr></tbody></table>
</div>

</div>
<br class="table-break"></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_applier_threshold"></a>
        <a class="indexterm" name="idm140572002419824"></a>

        <a class="indexterm" name="idm140572002418736"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_applier_threshold"><code class="literal">group_replication_flow_control_applier_threshold</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_flow_control_applier_threshold"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-flow-control-applier-threshold=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_applier_threshold">group_replication_flow_control_applier_threshold</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">25000</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table>
</div>
<p>
        Specifies the number of waiting transactions in the applier
        queue that trigger flow control. This variable can be changed
        without resetting Group Replication.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_certifier_threshold"></a>
        <a class="indexterm" name="idm140572002383088"></a>

        <a class="indexterm" name="idm140572002382080"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_certifier_threshold"><code class="literal">group_replication_flow_control_certifier_threshold</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_flow_control_certifier_threshold"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-flow-control-certifier-threshold=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_certifier_threshold">group_replication_flow_control_certifier_threshold</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">25000</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table>
</div>
<p>
        Specifies the number of waiting transactions in the certifier
        queue that trigger flow control. This variable can be changed
        without resetting Group Replication.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_hold_percent"></a>
        <a class="indexterm" name="idm140572002346272"></a>

        <a class="indexterm" name="idm140572002345264"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_hold_percent"><code class="literal">group_replication_flow_control_hold_percent</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_flow_control_hold_percent"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-flow-control-hold-percent=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_hold_percent">group_replication_flow_control_hold_percent</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">10</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">100</code></td>
</tr></tbody></table>
</div>
<p>
        Defines what percentage of the group quota remains unused to
        allow a cluster under flow control to catch up on backlog. A
        value of 0 implies that no part of the quota is reserved for
        catching up on the work backlog.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_max_commit_quota"></a>
        <a class="indexterm" name="idm140572002312384"></a>

        <a class="indexterm" name="idm140572002311296"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_max_commit_quota"><code class="literal">group_replication_flow_control_max_commit_quota</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_flow_control_max_commit_quota"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-flow-control-max-commit-quota=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_max_commit_quota">group_replication_flow_control_max_commit_quota</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table>
</div>
<p>
        Defines the maximum flow control quota of the group, or the
        maximum available quota for any period while flow control is
        enabled. A value of 0 implies that there is no maximum quota
        set. Cannot be smaller than
        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_quota"><code class="literal">group_replication_flow_control_min_quota</code></a>
        and
        <code class="literal">group_replication_flow_control_min_recovery_quota</code>.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_member_quota_percent"></a>
        <a class="indexterm" name="idm140572002276560"></a>

        <a class="indexterm" name="idm140572002275552"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_member_quota_percent"><code class="literal">group_replication_flow_control_member_quota_percent</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_flow_control_member_quota_percent"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-flow-control-member-quota-percent=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_member_quota_percent">group_replication_flow_control_member_quota_percent</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">100</code></td>
</tr></tbody></table>
</div>
<p>
        Defines the percentage of the quota that a member should assume
        is available for itself when calculating the quotas. A value of
        0 implies that the quota should be split equally between members
        that were writers in the last period.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_min_quota"></a>
        <a class="indexterm" name="idm140572002242256"></a>

        <a class="indexterm" name="idm140572002241248"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_quota"><code class="literal">group_replication_flow_control_min_quota</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_flow_control_min_quota"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-flow-control-min-quota=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_quota">group_replication_flow_control_min_quota</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table>
</div>
<p>
        Controls the lowest flow control quota that can be assigned to a
        member, independently of the calculated minimum quota executed
        in the last period. A value of 0 implies that there is no
        minimum quota. Cannot be larger than
        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_max_commit_quota"><code class="literal">group_replication_flow_control_max_commit_quota</code></a>.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_min_recovery_quota"></a>
        <a class="indexterm" name="idm140572002207200"></a>

        <a class="indexterm" name="idm140572002206192"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_recovery_quota"><code class="literal">group_replication_flow_control_min_recovery_quota</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_flow_control_min_recovery_quota"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-flow-control-min-recovery-quota=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_min_recovery_quota">group_replication_flow_control_min_recovery_quota</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table>
</div>
<p>
        Controls the lowest quota that can be assigned to a member
        because of another recovering member in the group, independently
        of the calculated minimum quota executed in the last period. A
        value of 0 implies that there is no minimum quota. Cannot be
        larger than
        <code class="literal">group_replication_flow_control_max_commit_quota</code>.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_flow_control_mode"></a>
        <a class="indexterm" name="idm140572002172240"></a>

        <a class="indexterm" name="idm140572002171232"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_flow_control_mode"><code class="literal">group_replication_flow_control_mode</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_flow_control_mode"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-flow-control-mode=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_flow_control_mode">group_replication_flow_control_mode</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Enumeration</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">QUOTA</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
<td><p class="valid-value"><code class="literal">DISABLED</code></p><p class="valid-value"><code class="literal">QUOTA</code></p></td>
</tr></tbody></table>
</div>
<p>
        Specifies the mode used for flow control. This variable can be
        changed without resetting Group Replication.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_force_members"></a>
        <a class="indexterm" name="idm140572002137696"></a>

        <a class="indexterm" name="idm140572002136688"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_force_members"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-force-members=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_force_members">group_replication_force_members</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>String</td>
</tr></tbody></table>
</div>
<p>
        A list of peer addresses as a comma separated list such as
        <code class="literal">host1:port1</code>,<code class="literal">host2:port2</code>.
        This option is used to force a new group membership, in which
        the excluded members do not receive a new view and are blocked.
        (You need to manually kill the excluded servers.) Any invalid
        host names in the list could cause this action to fail because
        they could block group membership. For a description of the
        procedure to follow, see
        <a class="xref" href="group-replication.html#group-replication-network-partitioning" title="17.4.3 Network Partitioning">Section 17.4.3, “Network Partitioning”</a>.
      </p><p>
        You must specify the address or host name and port as they are
        given in the
        <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
        option for each member. For example:
      </p><pre data-lang="simple" class="programlisting">"198.51.100.44:33061,example.org:33061"</pre><p>
        After you have used the
        <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
        system variable to successfully force a new group membership and
        unblock the group, ensure that you clear the system variable.
        <a class="link" href="group-replication.html#sysvar_group_replication_force_members"><code class="literal">group_replication_force_members</code></a>
        must be empty in order to issue a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START
        GROUP_REPLICATION</code></a> statement.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_group_name"></a>
        <a class="indexterm" name="idm140572002102304"></a>

        <a class="indexterm" name="idm140572002101296"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_group_name"><code class="literal">group_replication_group_name</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_group_name"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-group-name=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_group_name">group_replication_group_name</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>String</td>
</tr></tbody></table>
</div>
<p>
        The name of the group which this server instance belongs to.
        Must be a valid UUID. This UUID is used internally when setting
        GTIDs for Group Replication events in the binary log.
</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p>
          A unique UUID must be used.
</p>
</div>
</li><li class="listitem"><p><a name="sysvar_group_replication_group_seeds"></a>
        <a class="indexterm" name="idm140572002074064"></a>

        <a class="indexterm" name="idm140572002073056"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_group_seeds"><code class="literal">group_replication_group_seeds</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_group_seeds"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-group-seeds=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_group_seeds">group_replication_group_seeds</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>String</td>
</tr></tbody></table>
</div>
<p>
        A list of group members that provide a member which joins the
        group with the data required for the joining member to gain
        synchrony with the group. The list consists of the seed member's
        network addresses specified as a comma separated list, such as
        <code class="literal">host1:port1</code>,<code class="literal">host2:port2</code>.
</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p>
          These addresses must not be the member's SQL hostname and
          port.
</p>
</div>
<p>
        Note that the value you specify for this variable is not
        validated until a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START
        GROUP_REPLICATION</code></a> statement is issued and the Group
        Communication System (GCS) is available.
      </p><p>
        Usually this list consists of all members of the group, but you
        can choose a subset of the group members to be seeds. The list
        must contain at least one valid member address. Each address is
        validated when starting Group Replication. If the list does not
        contain any valid host names, issuing <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START
        GROUP_REPLICATION</code></a> fails.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_gtid_assignment_block_size"></a>
        <a class="indexterm" name="idm140572002041056"></a>

        <a class="indexterm" name="idm140572002040048"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_gtid_assignment_block_size"><code class="literal">group_replication_gtid_assignment_block_size</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_gtid_assignment_block_size"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-gtid-assignment-block-size=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_gtid_assignment_block_size">group_replication_gtid_assignment_block_size</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">1000000</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">1</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
<td><code class="literal">9223372036854775807</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table>
</div>
<p>
        The number of consecutive GTIDs that are reserved for each
        member. Each member consumes its blocks and reserves more when
        needed.
      </p><p>
        This system variable is a group-wide configuration setting. It
        must have the same value on all group members, cannot be changed
        while Group Replication is running, and requires a full reboot
        of the group (a bootstrap by a server with
        <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group=ON</code></a>)
        in order for the value change to take effect.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_ip_whitelist"></a>
        <a class="indexterm" name="idm140572001999712"></a>

        <a class="indexterm" name="idm140572001998704"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist"><code class="literal">group_replication_ip_whitelist</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_ip_whitelist"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-ip-whitelist=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist">group_replication_ip_whitelist</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>String</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">AUTOMATIC</code></td>
</tr></tbody></table>
</div>
<p>
        Specifies which hosts are permitted to connect to the group. The
        address that you specify for each group member in
        <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
        must be whitelisted on the other servers in the replication
        group. Note that the value you specify for this variable is not
        validated until a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START
        GROUP_REPLICATION</code></a> statement is issued and the Group
        Communication System (GCS) is available.
      </p><p>
        By default, this system variable is set to
        <code class="literal">AUTOMATIC</code>, which permits connections from
        private subnetworks active on the host. The group communication
        engine (XCom) automatically scans active interfaces on the host,
        and identifies those with addresses on private subnetworks.
        These addresses and the <code class="literal">localhost</code> IP address
        for IPv4 are used to create the Group Replication whitelist. For
        a list of the ranges from which addresses are automatically
        whitelisted, see
        <a class="xref" href="group-replication.html#group-replication-ip-address-whitelisting" title="17.5.1 Group Replication IP Address Whitelisting">Section 17.5.1, “Group Replication IP Address Whitelisting”</a>.
      </p><p>
        The automatic whitelist of private addresses cannot be used for
        connections from servers outside the private network. For Group
        Replication connections between server instances that are on
        different machines, you must provide public IP addresses and
        specify these as an explicit whitelist. If you specify any
        entries for the whitelist, the private and
        <code class="literal">localhost</code> addresses are not added
        automatically, so if you use any of these, you must specify them
        explicitly.
      </p><p>
        As the value of the
        <a class="link" href="group-replication.html#sysvar_group_replication_ip_whitelist"><code class="literal">group_replication_ip_whitelist</code></a>
        option, you can specify any combination of the following:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            IPv4 addresses (for example,
            <code class="literal">198.51.100.44</code>)
          </p></li><li class="listitem"><p>
            IPv4 addresses with CIDR notation (for example,
            <code class="literal">192.0.2.21/24</code>)
          </p></li><li class="listitem"><p>
            Host names, from MySQL 5.7.21 (for example,
            <code class="literal">example.org</code>)
          </p></li><li class="listitem"><p>
            Host names with CIDR notation, from MySQL 5.7.21 (for
            example, <code class="literal">www.example.com/24</code>)
</p></li></ul>
</div>
<p>
        IPv6 addresses, and host names that resolve to IPv6 addresses,
        are not supported in MySQL 5.7. You can use CIDR notation in
        combination with host names or IP addresses to whitelist a block
        of IP addresses with a particular network prefix, but do ensure
        that all the IP addresses in the specified subnet are under your
        control.
      </p><p>
        A comma must separate each entry in the whitelist. For example:
      </p><pre data-lang="none" class="programlisting">192.0.2.22,198.51.100.0/24,example.org,www.example.com/24</pre><p>
        It is possible to configure different whitelists on different
        group members according to your security requirements, for
        example, in order to keep different subnets separate. However,
        this can cause issues when a group is reconfigured. If you do
        not have a specific security requirement to do otherwise, use
        the same whitelist on all members of a group. For more details,
        see <a class="xref" href="group-replication.html#group-replication-ip-address-whitelisting" title="17.5.1 Group Replication IP Address Whitelisting">Section 17.5.1, “Group Replication IP Address Whitelisting”</a>.
      </p><p>
        For host names, name resolution takes place only when a
        connection request is made by another server. A host name that
        cannot be resolved is not considered for whitelist validation,
        and a warning message is written to the error log.
        Forward-confirmed reverse DNS (FCrDNS) verification is carried
        out for resolved host names.
</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Warning
</div>
<p>
          Host names are inherently less secure than IP addresses in a
          whitelist. FCrDNS verification provides a good level of
          protection, but can be compromised by certain types of attack.
          Specify host names in your whitelist only when strictly
          necessary, and ensure that all components used for name
          resolution, such as DNS servers, are maintained under your
          control. You can also implement name resolution locally using
          the hosts file, to avoid the use of external components.
</p>
</div>
</li><li class="listitem"><p><a name="sysvar_group_replication_local_address"></a>
        <a class="indexterm" name="idm140572001949408"></a>

        <a class="indexterm" name="idm140572001948400"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_local_address"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-local-address=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_local_address">group_replication_local_address</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>String</td>
</tr></tbody></table>
</div>
<p>
        The network address which the member provides for connections
        from other members, specified as a <code class="literal">host:port</code>
        formatted string. This address must be reachable by all members
        of the group because it is used by the group communication
        engine for Group Replication (XCom, a Paxos variant) for TCP
        communication between remote XCom instances. Communication with
        the local instance is over an input channel using shared memory.
</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Warning
</div>
<p>
          Do not use this address for communication with the member.
</p>
</div>
<p>
        Other Group Replication members contact this member through this
        <code class="literal">host:port</code> for all internal group
        communication. This is not the MySQL server SQL protocol host
        and port.
      </p><p>
        The address or host name that you specify in
        <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
        is used by Group Replication as the unique identifier for a
        group member within the replication group. You can use the same
        port for all members of a replication group as long as the host
        names or IP addresses are all different, and you can use the
        same host name or IP address for all members as long as the
        ports are all different. The recommended port for
        <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
        is 33061. Note that the value you specify for this variable is
        not validated until the <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START
        GROUP_REPLICATION</code></a> statement is issued and the Group
        Communication System (GCS) is available.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_member_weight"></a>
        <a class="indexterm" name="idm140572001914816"></a>

        <a class="indexterm" name="idm140572001913808"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_member_weight"><code class="literal">group_replication_member_weight</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_member_weight"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-member-weight=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.20</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_member_weight">group_replication_member_weight</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">50</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">100</code></td>
</tr></tbody></table>
</div>
<p>
        A percentage weight that can be assigned to members to influence
        the chance of the member being elected as primary in the event
        of failover, for example when the existing primary leaves a
        single-primary group. Assign numeric weights to members to
        ensure that specific members are elected, for example during
        scheduled maintenance of the primary or to ensure certain
        hardware is prioritized in the event of failover.
      </p><p>
        For a group with members configured as follows:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
            <code class="literal">member-1</code>:
            group_replication_member_weight=30, server_uuid=aaaa
          </p></li><li class="listitem"><p>
            <code class="literal">member-2</code>:
            group_replication_member_weight=40, server_uuid=bbbb
          </p></li><li class="listitem"><p>
            <code class="literal">member-3</code>:
            group_replication_member_weight=40, server_uuid=cccc
          </p></li><li class="listitem"><p>
            <code class="literal">member-4</code>:
            group_replication_member_weight=40, server_uuid=dddd
</p></li></ul>
</div>
<p>
        during election of a new primary the members above would be
        sorted as <code class="literal">member-2</code>,
        <code class="literal">member-3</code>, <code class="literal">member-4</code>, and
        <code class="literal">member-1</code>. This results in
        <code class="literal">member</code>-2 being chosen as the new primary in
        the event of failover. For more information, see
        <a class="xref" href="group-replication.html#group-replication-single-primary-mode" title="17.4.1.1 Single-Primary Mode">Section 17.4.1.1, “Single-Primary Mode”</a>.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_poll_spin_loops"></a>
        <a class="indexterm" name="idm140572001867184"></a>

        <a class="indexterm" name="idm140572001866176"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_poll_spin_loops"><code class="literal">group_replication_poll_spin_loops</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_poll_spin_loops"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-poll-spin-loops=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_poll_spin_loops">group_replication_poll_spin_loops</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (64-bit platforms)</td>
<td><code class="literal">18446744073709551615</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span> (32-bit platforms)</td>
<td><code class="literal">4294967295</code></td>
</tr></tbody></table>
</div>
<p>
        The number of times the group communication thread waits for the
        communication engine mutex to be released before the thread
        waits for more incoming network messages.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_retry_count"></a>
        <a class="indexterm" name="idm140572001827632"></a>

        <a class="indexterm" name="idm140572001826624"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_retry_count"><code class="literal">group_replication_recovery_retry_count</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_retry_count"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-retry-count=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_retry_count">group_replication_recovery_retry_count</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">10</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">31536000</code></td>
</tr></tbody></table>
</div>
<p>
        The number of times that the member that is joining tries to
        connect to the available donors before giving up.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_reconnect_interval"></a>
        <a class="indexterm" name="idm140572001791360"></a>

        <a class="indexterm" name="idm140572001790272"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_reconnect_interval"><code class="literal">group_replication_recovery_reconnect_interval</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_reconnect_interval"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-reconnect-interval=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_reconnect_interval">group_replication_recovery_reconnect_interval</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">60</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">31536000</code></td>
</tr></tbody></table>
</div>
<p>
        The sleep time, in seconds, between reconnection attempts when
        no donor was found in the group.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_use_ssl"></a>
        <a class="indexterm" name="idm140572001754944"></a>

        <a class="indexterm" name="idm140572001753936"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_use_ssl"><code class="literal">group_replication_recovery_use_ssl</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_use_ssl"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-use-ssl[={OFF|ON}]</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_use_ssl">group_replication_recovery_use_ssl</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Boolean</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">OFF</code></td>
</tr></tbody></table>
</div>
<p>
        Whether Group Replication recovery connection should use SSL or
        not.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_ca"></a>
        <a class="indexterm" name="idm140572001724624"></a>

        <a class="indexterm" name="idm140572001723616"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_ca"><code class="literal">group_replication_recovery_ssl_ca</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_ca"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-ssl-ca=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_ca">group_replication_recovery_ssl_ca</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>String</td>
</tr></tbody></table>
</div>
<p>
        The path to a file that contains a list of trusted SSL
        certificate authorities.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_capath"></a>
        <a class="indexterm" name="idm140572001697264"></a>

        <a class="indexterm" name="idm140572001696256"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_capath"><code class="literal">group_replication_recovery_ssl_capath</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_capath"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-ssl-capath=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_capath">group_replication_recovery_ssl_capath</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>String</td>
</tr></tbody></table>
</div>
<p>
        The path to a directory that contains trusted SSL certificate
        authority certificates.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_cert"></a>
        <a class="indexterm" name="idm140572001669888"></a>

        <a class="indexterm" name="idm140572001668880"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_cert"><code class="literal">group_replication_recovery_ssl_cert</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_cert"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-ssl-cert=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_cert">group_replication_recovery_ssl_cert</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>String</td>
</tr></tbody></table>
</div>
<p>
        The name of the SSL certificate file to use for establishing a
        secure connection.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_key"></a>
        <a class="indexterm" name="idm140572001642512"></a>

        <a class="indexterm" name="idm140572001641504"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_key"><code class="literal">group_replication_recovery_ssl_key</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_key"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-ssl-key=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_key">group_replication_recovery_ssl_key</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>String</td>
</tr></tbody></table>
</div>
<p>
        The name of the SSL key file to use for establishing a secure
        connection.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_cipher"></a>
        <a class="indexterm" name="idm140572001615152"></a>

        <a class="indexterm" name="idm140572001614144"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_cipher"><code class="literal">group_replication_recovery_ssl_cipher</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_cipher"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-ssl-cipher=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_cipher">group_replication_recovery_ssl_cipher</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>String</td>
</tr></tbody></table>
</div>
<p>
        The list of permissible ciphers for SSL encryption.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_crl"></a>
        <a class="indexterm" name="idm140572001587824"></a>

        <a class="indexterm" name="idm140572001586816"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_crl"><code class="literal">group_replication_recovery_ssl_crl</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_crl"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-ssl-crl=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_crl">group_replication_recovery_ssl_crl</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>File name</td>
</tr></tbody></table>
</div>
<p>
        The path to a directory that contains files containing
        certificate revocation lists.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_crlpath"></a>
        <a class="indexterm" name="idm140572001560448"></a>

        <a class="indexterm" name="idm140572001559440"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_crlpath"><code class="literal">group_replication_recovery_ssl_crlpath</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_crlpath"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-ssl-crlpath=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_crlpath">group_replication_recovery_ssl_crlpath</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Directory name</td>
</tr></tbody></table>
</div>
<p>
        The path to a directory that contains files containing
        certificate revocation lists.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_ssl_verify_server_cert"></a>
        <a class="indexterm" name="idm140572001532832"></a>

        <a class="indexterm" name="idm140572001531824"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_verify_server_cert"><code class="literal">group_replication_recovery_ssl_verify_server_cert</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_ssl_verify_server_cert"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-ssl-verify-server-cert[={OFF|ON}]</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_ssl_verify_server_cert">group_replication_recovery_ssl_verify_server_cert</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Boolean</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">OFF</code></td>
</tr></tbody></table>
</div>
<p>
        Make the recovery process check the server's Common Name value
        in the donor sent certificate.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_recovery_complete_at"></a>
        <a class="indexterm" name="idm140572001501936"></a>

        <a class="indexterm" name="idm140572001500928"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_recovery_complete_at"><code class="literal">group_replication_recovery_complete_at</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_recovery_complete_at"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-recovery-complete-at=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_recovery_complete_at">group_replication_recovery_complete_at</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Enumeration</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">TRANSACTIONS_APPLIED</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
<td><p class="valid-value"><code class="literal">TRANSACTIONS_CERTIFIED</code></p><p class="valid-value"><code class="literal">TRANSACTIONS_APPLIED</code></p></td>
</tr></tbody></table>
</div>
<p>
        Recovery policies when handling cached transactions after state
        transfer. This option specifies whether a member is marked
        online after it has received all transactions that it missed
        before it joined the group
        (<code class="literal">TRANSACTIONS_CERTIFIED</code>) or after it has
        received and applied them
        (<code class="literal">TRANSACTIONS_APPLIED</code>).
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_single_primary_mode"></a>
        <a class="indexterm" name="idm140572001466016"></a>

        <a class="indexterm" name="idm140572001465008"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode"><code class="literal">group_replication_single_primary_mode</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_single_primary_mode"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-single-primary-mode[={OFF|ON}]</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode">group_replication_single_primary_mode</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Boolean</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">ON</code></td>
</tr></tbody></table>
</div>
<p>
        Instructs the group to automatically pick a single server to be
        the one that handles read/write workload. This server is the
        PRIMARY and all others are SECONDARIES.
      </p><p>
        This system variable is a group-wide configuration setting. It
        must have the same value on all group members, cannot be changed
        while Group Replication is running, and requires a full reboot
        of the group (a bootstrap by a server with
        <a class="link" href="group-replication.html#sysvar_group_replication_bootstrap_group"><code class="literal">group_replication_bootstrap_group=ON</code></a>)
        in order for the value change to take effect.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_ssl_mode"></a>
        <a class="indexterm" name="idm140572001433856"></a>

        <a class="indexterm" name="idm140572001432848"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_ssl_mode"><code class="literal">group_replication_ssl_mode</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_ssl_mode"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-ssl-mode=value</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_ssl_mode">group_replication_ssl_mode</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Enumeration</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">DISABLED</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Valid Values</strong></span></td>
<td><p class="valid-value"><code class="literal">DISABLED</code></p><p class="valid-value"><code class="literal">REQUIRED</code></p><p class="valid-value"><code class="literal">VERIFY_CA</code></p><p class="valid-value"><code class="literal">VERIFY_IDENTITY</code></p></td>
</tr></tbody></table>
</div>
<p>
        Specifies the security state of the connection between Group
        Replication members.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_start_on_boot"></a>
        <a class="indexterm" name="idm140572001397600"></a>

        <a class="indexterm" name="idm140572001396592"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot"><code class="literal">group_replication_start_on_boot</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_start_on_boot"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-start-on-boot[={OFF|ON}]</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.17</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_start_on_boot">group_replication_start_on_boot</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Boolean</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">ON</code></td>
</tr></tbody></table>
</div>
<p>
        Whether the server should start Group Replication or not during
        server start.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_transaction_size_limit"></a>
        <a class="indexterm" name="idm140572001367280"></a>

        <a class="indexterm" name="idm140572001366192"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit"><code class="literal">group_replication_transaction_size_limit</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_transaction_size_limit"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-transaction-size-limit=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.19</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit">group_replication_transaction_size_limit</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">2147483647</code></td>
</tr></tbody></table>
</div>
<p>
        Configures the maximum transaction size in bytes which the
        replication group accepts. Transactions larger than this size
        are rolled back by the receiving member and are not broadcast to
        the group. Large transactions can cause problems for a
        replication group in terms of memory allocation, which can cause
        the system to slow down, or in terms of network bandwidth
        consumption, which can cause a member to be suspected of having
        failed because it is busy processing the large transaction.
      </p><p>
        When this system variable is set to 0, which is the default in
        MySQL 5.7, there is no limit to the size of transactions the
        group accepts. From MySQL 8.0, the default setting for this
        system variable is 150000000 bytes (approximately 143 MB).
        Adjust the value of this system variable depending on the
        maximum message size that you need the group to tolerate,
        bearing in mind that the time taken to process a transaction is
        proportional to its size. The value of
        <a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit"><code class="literal">group_replication_transaction_size_limit</code></a>
        should be the same on all group members. For further mitigation
        strategies for large transactions, see
        <a class="xref" href="group-replication.html#group-replication-limitations" title="17.7.2 Group Replication Limitations">Section 17.7.2, “Group Replication Limitations”</a>.
      </p></li><li class="listitem"><p><a name="sysvar_group_replication_unreachable_majority_timeout"></a>
        <a class="indexterm" name="idm140572001327936"></a>

        <a class="indexterm" name="idm140572001326928"></a>

        <a class="link" href="group-replication.html#sysvar_group_replication_unreachable_majority_timeout"><code class="literal">group_replication_unreachable_majority_timeout</code></a>
</p>
<div class="informaltable">
<table frame="box" rules="all" summary="Properties for group_replication_unreachable_majority_timeout"><col width="30%"><col width="70%"><thead><tr><th scope="col">Property</th>
<th scope="col">Value</th>
</tr></thead><tbody><tr><td scope="row"><span class="bold"><strong>Command-Line Format</strong></span></td>
<td><code class="literal">--group-replication-unreachable-majority-timeout=#</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Introduced</strong></span></td>
<td>5.7.19</td>
</tr><tr><td scope="row"><span class="bold"><strong>System Variable</strong></span></td>
<td><code class="literal"><a class="link" href="group-replication.html#sysvar_group_replication_unreachable_majority_timeout">group_replication_unreachable_majority_timeout</a></code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Scope</strong></span></td>
<td>Global</td>
</tr><tr><td scope="row"><span class="bold"><strong>Dynamic</strong></span></td>
<td>Yes</td>
</tr><tr><td scope="row"><span class="bold"><strong>Type</strong></span></td>
<td>Integer</td>
</tr><tr><td scope="row"><span class="bold"><strong>Default Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Minimum Value</strong></span></td>
<td><code class="literal">0</code></td>
</tr><tr><td scope="row"><span class="bold"><strong>Maximum Value</strong></span></td>
<td><code class="literal">31536000</code></td>
</tr></tbody></table>
</div>
<p>
        Configures how long members that suffer a network partition and
        cannot connect to the majority wait before leaving the group.
      </p><p>
        In a group of 5 servers (S1,S2,S3,S4,S5), if there is a
        disconnection between (S1,S2) and (S3,S4,S5) there is a network
        partition. The first group (S1,S2) is now in a minority because
        it cannot contact more than half of the group. While the
        majority group (S3,S4,S5) remains running, the minority group
        waits for the specified time for a network reconnection. Any
        transactions processed by the minority group are blocked until
        Group Replication is stopped using <a class="link" href="sql-syntax.html#stop-group-replication" title="13.4.3.2 STOP GROUP_REPLICATION Syntax"><code class="literal">STOP
        GROUP REPLICATION</code></a> on the members of the minority. Note
        that
        <a class="link" href="group-replication.html#sysvar_group_replication_unreachable_majority_timeout"><code class="literal">group_replication_unreachable_majority_timeout</code></a>
        has no effect if it is set on the servers in the minority group
        after the loss of majority has been detected.
      </p><p>
        By default, this system variable is set to 0, which means that
        members that find themselves in a minority due to a network
        partition wait forever to leave the group. If configured to a
        number of seconds, members wait for this amount of time after
        losing contact with the majority of members before leaving the
        group. When the specified time elapses, all pending transactions
        processed by the minority are rolled back, and the servers in
        the minority partition move to the <code class="literal">ERROR</code>
        state. These servers then follow the action specified by the
        system variable
        <a class="link" href="group-replication.html#sysvar_group_replication_exit_state_action"><code class="literal">group_replication_exit_state_action</code></a>,
        which can be to set themselves to super read only mode or shut
        down MySQL.
</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Warning
</div>
<p>
          When you have a symmetric group, with just two members for
          example (S0,S2), if there is a network partition and there is
          no majority, after the configured timeout all members enter
          <code class="literal">ERROR</code> state.
</p>
</div>
</li></ul>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-status-variables"></a>Group Replication Status Variable</h3>

</div>

</div>

</div>
<p>
      This section describes the status variables which provide
      information about Group Replication. The variable has the
      following meaning:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <a class="link" href="server-administration.html#statvar_group_replication_primary_member"><code class="literal">group_replication_primary_member</code></a>
        </p><p>
          Shows the primary member's UUID when the group is operating in
          single-primary mode. If the group is operating in
          multi-primary mode, shows an empty string. See
          <a class="xref" href="group-replication.html#group-replication-find-primary" title="17.4.1.3 Finding the Primary">Section 17.4.1.3, “Finding the Primary”</a>.
</p></li></ul>
</div>

</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="group-replication-requirements-and-limitations"></a>17.7 Requirements and Limitations</h2>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-requirements">17.7.1 Group Replication Requirements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-limitations">17.7.2 Group Replication Limitations</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572001278816"></a><p>
    This section lists and explains the requirements and limitations of
    Group Replication.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-requirements"></a>17.7.1 Group Replication Requirements</h3>
</div>
</div>
</div>
<a class="indexterm" name="idm140572001276048"></a><p>
      Server instances that you want to use for Group Replication must
      satisfy the following requirements.
</p>
<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h4 class="title"><a name="group-replication-infrastructure"></a>Infrastructure</h4>
</div>
</div>
</div>

<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>InnoDB Storage Engine. </b>
              Data must be stored in the
              <a class="link" href="innodb-storage-engine.html" title="Chapter 14 The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> transactional storage
              engine. Transactions are executed optimistically and then,
              at commit time, are checked for conflicts. If there are
              conflicts, in order to maintain consistency across the
              group, some transactions are rolled back. This means that
              a transactional storage engine is required. Moreover,
              <a class="link" href="innodb-storage-engine.html" title="Chapter 14 The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> provides some
              additional functionality that enables better management
              and handling of conflicts when operating together with
              Group Replication. The use of other storage engines,
              including the temporary
              <a class="link" href="storage-engines.html#memory-storage-engine" title="15.3 The MEMORY Storage Engine"><code class="literal">MEMORY</code></a> storage engine, might
              cause errors in Group Replication. You can prevent the use
              of other storage engines by setting the
              <a class="link" href="server-administration.html#sysvar_disabled_storage_engines"><code class="literal">disabled_storage_engines</code></a>
              system variable on group members, for example:
            </p><pre data-lang="ini" class="programlisting">
disabled_storage_engines="MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"
</pre></li><li class="listitem"><p><b>Primary Keys. </b>
              Every table that is to be replicated by the group must
              have a defined primary key, or primary key equivalent
              where the equivalent is a non-null unique key. Such keys
              are required as a unique identifier for every row within a
              table, enabling the system to determine which transactions
              conflict by identifying exactly which rows each
              transaction has modified.
            </p></li><li class="listitem"><p><b>IPv4 Network. </b>
              The group communication engine used by MySQL Group
              Replication only supports IPv4. Therefore, Group
              Replication requires an IPv4 network infrastructure.
            </p></li><li class="listitem"><p><b>Network Performance. </b>
              MySQL Group Replication is designed to be deployed in a
              cluster environment where server instances are very close
              to each other. The performance and stabiity of a group can
              be impacted by both network latency and network bandwidth.
              Bi-directional communication must be maintained at all
              times between all group members. If either inbound or
              outbound communication is blocked for a server instance
              (for example, by a firewall, or by connectivity issues),
              the member cannot function in the group, and the group
              members (including the member with issues) might not be
              able to report the correct member status for the affected
              server instance.
</p></li></ul>
</div>

</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="group-replication-configuration"></a>Server Instance Configuration</h4>

</div>

</div>

</div>
<p>
        The following options must be configured on server instances
        that are members of a group.
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Binary Log Active. </b>
              Set
              <a class="link" href="replication.html#sysvar_log_bin"><code class="literal">--log-bin[=log_file_name]</code></a>.
              MySQL Group Replication replicates binary log contents,
              therefore the binary log needs to be on for it to operate.
              This option is enabled by default. See
              <a class="xref" href="server-administration.html#binary-log" title="5.4.4 The Binary Log">Section 5.4.4, “The Binary Log”</a>.
            </p></li><li class="listitem"><p><b>Slave Updates Logged. </b>
              Set <a class="link" href="replication.html#sysvar_log_slave_updates"><code class="literal">--log-slave-updates</code></a>.
              Servers need to log binary logs that are applied through
              the replication applier. Servers in the group need to log
              all transactions that they receive and apply from the
              group. This is required because recovery is conducted by
              relying on binary logs form participants in the group.
              Therefore, copies of each transaction need to exist on
              every server, even for those transactions that were not
              initiated on the server itself.
            </p></li><li class="listitem"><p><b>Binary Log Row Format. </b>
              Set <a class="link" href="replication.html#sysvar_binlog_format"><code class="literal">--binlog-format=row</code></a>.
              Group Replication relies on row-based replication format
              to propagate changes consistently among the servers in the
              group. It relies on row-based infrastructure to be able to
              extract the necessary information to detect conflicts
              among transactions that execute concurrently in different
              servers in the group. See
              <a class="xref" href="replication.html#replication-formats" title="16.2.1 Replication Formats">Section 16.2.1, “Replication Formats”</a>.
            </p></li><li class="listitem"><p><b>Binary Log Checksums Off. </b>
              Set
              <a class="link" href="replication.html#sysvar_binlog_checksum"><code class="literal">--binlog-checksum=NONE</code></a>.
              Due to a design limitation of replication event checksums,
              Group Replication cannot make use of them, and they must
              be disabled.
            </p></li><li class="listitem"><p><b>Global Transaction Identifiers On. </b>
              Set <a class="link" href="replication.html#sysvar_gtid_mode"><code class="literal">gtid_mode=ON</code></a>. Group
              Replication uses global transaction identifiers to track
              exactly which transactions have been committed on every
              server instance and thus be able to infer which servers
              have executed transactions that could conflict with
              already committed transactions elsewhere. In other words,
              explicit transaction identifiers are a fundamental part of
              the framework to be able to determine which transactions
              may conflict. See <a class="xref" href="replication.html#replication-gtids" title="16.1.3 Replication with Global Transaction Identifiers">Section 16.1.3, “Replication with Global Transaction Identifiers”</a>.
            </p></li><li class="listitem"><p><b>Replication Information Repositories. </b>
              Set
              <a class="link" href="replication.html#sysvar_master_info_repository"><code class="literal">--master-info-repository=TABLE</code></a>
              and
              <a class="link" href="replication.html#sysvar_relay_log_info_repository"><code class="literal">--relay-log-info-repository=TABLE</code></a>.
              The replication applier needs to have the master
              information and relay log metadata written to the
              <code class="literal">mysql.slave_master_info</code> and
              <code class="literal">mysql.slave_relay_log_info</code> system
              tables. This ensures the Group Replication plugin has
              consistent recoverability and transactional management of
              the replication metadata. See
              <a class="xref" href="replication.html#slave-logs-status" title="16.2.4.2 Slave Status Logs">Section 16.2.4.2, “Slave Status Logs”</a>.
            </p></li><li class="listitem"><p><b>Transaction Write Set Extraction. </b>
              Set
              <a class="link" href="replication.html#sysvar_transaction_write_set_extraction"><code class="literal">--transaction-write-set-extraction=XXHASH64</code></a>
              so that while collecting rows to log them to the binary
              log, the server collects the write set as well. The write
              set is based on the primary keys of each row and is a
              simplified and compact view of a tag that uniquely
              identifies the row that was changed. This tag is then used
              for detecting conflicts.
            </p></li><li class="listitem"><p><b>Lower Case Table Names. </b>
              Set
              <a class="link" href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">--lower-case-table-names</code></a>
              to the same value on all group members. A setting of 1 is
              correct for the use of the
              <a class="link" href="innodb-storage-engine.html" title="Chapter 14 The InnoDB Storage Engine"><code class="literal">InnoDB</code></a> storage engine, which
              is required for Group Replication. Note that this setting
              is not the default on all platforms.
            </p></li><li class="listitem"><p><b>Multithreaded Appliers. </b>
              Group Replication members can be configured as
              multithreaded appliers, enabling transactions to be
              applied in parallel. Set
              <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">--slave-parallel-workers=N</code></a>
              (where <code class="literal">N</code> is the number of parallel
              applier threads),
              <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">--slave-preserve-commit-order=1</code></a>,
              and
              <a class="link" href="replication.html#sysvar_slave_parallel_type"><code class="literal">--slave-parallel-type=LOGICAL_CLOCK</code></a>.
              Setting
              <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">--slave-parallel-workers=N</code></a>
              enables the multithreaded applier on the member. Group
              Replication relies on consistency mechanisms built around
              the guarantee that all participating members receive and
              apply committed transaction in the same order, so you must
              also set
              <a class="link" href="replication.html#sysvar_slave_preserve_commit_order"><code class="literal">--slave-preserve-commit-order=1</code></a>
              to ensure that the final commit of parallel transactions
              is in the same order as the original transactions.
              Finally, in order to determine which transactions can be
              executed in parallel, the relay log must contain
              transaction parent information generated with
              <a class="link" href="replication.html#sysvar_slave_parallel_type"><code class="literal">--slave-parallel-type=LOGICAL_CLOCK</code></a>.
              Attempting to add a member with
              <a class="link" href="replication.html#sysvar_slave_parallel_workers"><code class="literal">--slave-parallel-workers</code></a>
              set to greater than 0 without also setting the other two
              options, generates an error and the instance is prevented
              from joining.
</p></li></ul>
</div>

</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-limitations"></a>17.7.2 Group Replication Limitations</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572001213072"></a><p>
      The following known limitations exist for Group Replication. Note
      that the limitations and issues described for multi-primary mode
      groups can also apply in single-primary mode clusters during a
      failover event, while the newly elected primary flushes out its
      applier queue from the old primary.
</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Tip
</div>
<p>
        Group Replication is built on GTID based replication, therefore
        you should also be aware of
        <a class="xref" href="replication.html#replication-gtids-restrictions" title="16.1.3.6 Restrictions on Replication with GTIDs">Section 16.1.3.6, “Restrictions on Replication with GTIDs”</a>.
</p>
</div>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><b>Gap Locks. </b>
            The certification process does not take into account
            <a class="link" href="glossary.html#glos_gap_lock" title="gap lock">gap locks</a>, as
            information about gap locks is not available outside of
            <a class="link" href="innodb-storage-engine.html" title="Chapter 14 The InnoDB Storage Engine"><code class="literal">InnoDB</code></a>. See
            <a class="xref" href="innodb-storage-engine.html#innodb-gap-locks" title="Gap Locks">Gap Locks</a> for more information.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
            Unless you rely on <a class="link" href="innodb-storage-engine.html#isolevel_repeatable-read"><code class="literal">REPEATABLE
            READ</code></a> semantics in your applications, we recommend
            using the <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ COMMITTED</code></a>
            isolation level with Group Replication. InnoDB does not use
            gap locks in <a class="link" href="innodb-storage-engine.html#isolevel_read-committed"><code class="literal">READ
            COMMITTED</code></a>, which aligns the local conflict
            detection within InnoDB with the distributed conflict
            detection performed by Group Replication.
</p>
</div>
</li><li class="listitem"><p><b>Table Locks and Named Locks. </b>
            The certification process does not take into account table
            locks (see <a class="xref" href="sql-syntax.html#lock-tables" title="13.3.5 LOCK TABLES and UNLOCK TABLES Syntax">Section 13.3.5, “LOCK TABLES and UNLOCK TABLES Syntax”</a>) or named locks
            (see <a class="link" href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a>).
          </p></li><li class="listitem"><p><b>Replication Event Checksums. </b>
            Due to a design limitation of replication event checksums,
            Group Replication cannot currently make use of them.
            Therefore set
            <a class="link" href="replication.html#sysvar_binlog_checksum"><code class="literal">--binlog-checksum=NONE</code></a>.
          </p></li><li class="listitem"><p><b>SERIALIZABLE Isolation Level. </b>
            <a class="link" href="innodb-storage-engine.html#isolevel_serializable"><code class="literal">SERIALIZABLE</code></a> isolation
            level is not supported in multi-primary groups by default.
            Setting a transaction isolation level to
            <code class="literal">SERIALIZABLE</code> configures Group Replication
            to refuse to commit the transaction.
          </p></li><li class="listitem"><p><b>Concurrent DDL versus DML Operations. </b>
            Concurrent data definition statements and data manipulation
            statements executing against the same object but on
            different servers is not supported when using multi-primary
            mode. During execution of Data Definition Language (DDL)
            statements on an object, executing concurrent Data
            Manipulation Language (DML) on the same object but on a
            different server instance has the risk of conflicting DDL
            executing on different instances not being detected.
          </p></li><li class="listitem"><p><b>Foreign Keys with Cascading Constraints. </b>
            Multi-primary mode groups (members all configured with
            <a class="link" href="group-replication.html#sysvar_group_replication_single_primary_mode"><code class="literal">group_replication_single_primary_mode=OFF</code></a>)
            do not support tables with multi-level foreign key
            dependencies, specifically tables that have defined
            <code class="literal">CASCADING</code>
            <a class="link" href="glossary.html#glos_foreign_key_constraint" title="FOREIGN KEY constraint"> foreign key
            constraints</a>. This is because foreign key constraints
            that result in cascading operations executed by a
            multi-primary mode group can result in undetected conflicts
            and lead to inconsistent data across the members of the
            group. Therefore we recommend setting
            <a class="link" href="group-replication.html#sysvar_group_replication_enforce_update_everywhere_checks"><code class="literal">group_replication_enforce_update_everywhere_checks=ON</code></a>
            on server instances used in multi-primary mode groups to
            avoid undetected conflicts.
          </p><p>
          In single-primary mode this is not a problem as it does not
          allow concurrent writes to multiple members of the group and
          thus there is no risk of undetected conflicts.
        </p></li><li class="listitem"><p><b>MySQL Enterprise Audit and MySQL Enterprise Firewall. </b>
            Prior to version 5.7.21 MySQL Enterprise Audit and MySQL Enterprise Firewall use
            <code class="literal">MyISAM</code> tables in the
            <code class="literal">mysql</code> system database. Group Replication
            does not support <code class="literal">MyISAM</code> tables.

            
          </p><a class="indexterm" name="idm140572001175504"></a><a class="indexterm" name="idm140572001174016"></a></li><li class="listitem"><p><b>Multi-primary Mode Deadlock. </b>
            When a group is operating in multi-primary mode,
            <code class="literal">SELECT .. FOR UPDATE</code> statements can
            result in a deadlock. This is because the lock is not shared
            across the members of the group, therefore the expectation
            for such a statement might not be reached.
          </p></li><li class="listitem"><p><b>Replication Filters. </b>
            Replication filters cannot be used on a MySQL server
            instance that is configured for Group Replication, because
            filtering transactions on some servers would make the group
            unable to reach agreement on a consistent state.
</p></li></ul>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="idm140572001167792"></a>Limit on Group Size</h4>

</div>

</div>

</div>
<p>
        The maximum number of MySQL servers that can be members of a
        single replication group is 9. If further members attempt to
        join the group, their request is refused. This limit has been
        identified from testing and benchmarking as a safe boundary
        where the group performs reliably on a stable local area
        network.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h4 class="title"><a name="idm140572001165920"></a>Limits on Transaction Size</h4>

</div>

</div>

</div>
<p>
        If an individual transaction results in message contents which
        are large enough that the message cannot be copied between group
        members over the network within a 5-second window, members can
        be suspected of having failed, and then expelled, just because
        they are busy processing the transaction. Large transactions can
        also cause the system to slow due to problems with memory
        allocation. To avoid these issues use the following mitigations:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            Where possible, try and limit the size of your transactions.
            For example, split up files used with <code class="literal">LOAD
            DATA</code> into smaller chunks.
          </p></li><li class="listitem"><p>
            Use the system variable
            <a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit"><code class="literal">group_replication_transaction_size_limit</code></a>
            to specify a maximum transaction size that the group will
            accept. In MySQL 5.7, this system variable defaults to zero,
            but in MySQL 8.0, it defaults to a maximum transaction size
            of 150000000 bytes (approximately 143 MB). Transactions
            above this limit are rolled back and are not sent to Group
            Replication's Group Communication System (GCS) for
            distribution to the group. Adjust the value of this variable
            depending on the maximum message size that you need the
            group to tolerate, bearing in mind that the time taken to
            process a transaction is proportional to its size.
          </p></li><li class="listitem"><p>
            Use the system variable
            <a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold"><code class="literal">group_replication_compression_threshold</code></a>
            to specify a message size above which compression is
            applied. This system variable defaults to 1000000 bytes (1
            MB), so large messages are automatically compressed.
            Compression is carried out by Group Replication's Group
            Communication System (GCS) when it receives a message that
            was permitted by the
            <a class="link" href="group-replication.html#sysvar_group_replication_transaction_size_limit"><code class="literal">group_replication_transaction_size_limit</code></a>
            setting but exceeds the
            <a class="link" href="group-replication.html#sysvar_group_replication_compression_threshold"><code class="literal">group_replication_compression_threshold</code></a>
            setting. If you set the system variable value to zero,
            compression is deactivated. For more information, see
            <a class="xref" href="group-replication.html#group-replication-message-compression" title="17.9.7.2 Message Compression">Section 17.9.7.2, “Message Compression”</a>.
</p></li></ul>
</div>
<p>
        If you have deactivated message compression and do not specify a
        maximum transaction size, the upper size limit for a message
        that can be handled by the applier thread on a member of a
        replication group is the value of the member's
        <a class="link" href="replication.html#sysvar_slave_max_allowed_packet"><code class="literal">slave_max_allowed_packet</code></a> system
        variable, which has a default and maximum value of 1073741824
        bytes (1 GB). A message that exceeds this limit fails when the
        receiving member attempts to handle it. The upper size limit for
        a message that a group member can originate and attempt to
        transmit to the group is 4294967295 bytes (approximately 4 GB).
        This is a hard limit on the packet size that is accepted by the
        group communication engine for Group Replication (XCom, a Paxos
        variant), which receives messages after GCS has handled them. A
        message that exceeds this limit fails when the originating
        member attempts to broadcast it.
</p>
</div>

</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="group-replication-frequently-asked-questions"></a>17.8 Frequently Asked Questions</h2>

</div>

</div>

</div>
<a class="indexterm" name="idm140572001148640"></a><p>
    This section provides answers to frequently asked questions.
</p>
<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h3 class="title"><a name="group-replication-maximum-number-servers"></a>What is the maximum number of MySQL servers in a group?</h3>
</div>
</div>
</div>
<p>
      A group can consist of maximum 9 servers. Attempting to add
      another server to a group with 9 members causes the request to
      join to be refused. This limit has been identified from testing
      and benchmarking as a safe boundary where the group performs
      reliably on a stable local area network.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-servers-in-a-group-connected"></a>How are servers in a group connected?</h3>

</div>

</div>

</div>
<p>
      Servers in a group connect to the other servers in the group by
      opening a peer-to-peer TCP connection. These connections are only
      used for internal communication and message passing between
      servers in the group. This address is configured by the
      <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>
      variable.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-what-is-the-group-replication-bootstrap-group-option-used-for"></a>What is the group_replication_bootstrap_group option used for?</h3>

</div>

</div>

</div>
<p>
      The bootstrap flag instructs a member to
      <span class="emphasis"><em>create</em></span> a group and act as the initial seed
      server. The second member joining the group needs to ask the
      member that bootstrapped the group to dynamically change the
      configuration in order for it to be added to the group.
    </p><p>
      A member needs to bootstrap the group in two scenarios. When the
      group is originally created, or when shutting down and restarting
      the entire group.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-credentials-for-recovery"></a>How do I set credentials for the recovery procedure?</h3>

</div>

</div>

</div>
<p>
      You pre-configure the Group Replication recovery channel
      credentials using the <a class="link" href="sql-syntax.html#change-master-to" title="13.4.2.1 CHANGE MASTER TO Syntax"><code class="literal">CHANGE MASTER
      TO</code></a> statement.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-scale-out-write-load"></a>Can I scale-out my write-load using Group Replication?</h3>

</div>

</div>

</div>
<p>
      Not directly, but MySQL Group replication is a shared nothing full
      replication solution, where all servers in the group replicate the
      same amount of data. Therefore if one member in the group writes N
      bytes to storage as the result of a transaction commit operation,
      then roughly N bytes are written to storage on other members as
      well, because the transaction is replicated everywhere.
    </p><p>
      However, given that other members do not have to do the same
      amount of processing that the original member had to do when it
      originally executed the transaction, they apply the changes
      faster. Transactions are replicated in a format that is used to
      apply row transformations only, without having to re-execute
      transactions again (row-based format).
    </p><p>
      Furthermore, given that changes are propagated and applied in
      row-based format, this means that they are received in an
      optimized and compact format, and likely reducing the number of IO
      operations required when compared to the originating member.
    </p><p>
      To summarize, you can scale-out processing, by spreading conflict
      free transactions throughout different members in the group. And
      you can likely scale-out a small fraction of your IO operations,
      since remote servers receive only the necessary changes to
      read-modify-write changes to stable storage.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-performance-compared"></a>Does Group Replication require more network bandwidth and CPU, when
compared to simple replication and under the same workload?</h3>
</div>
</div>
</div>
<p>
      Some additional load is expected because servers need to be
      constantly interacting with each other for synchronization
      purposes. It is difficult to quantify how much more data. It also
      depends on the size of the group (three servers puts less stress
      on the bandwidth requirements than nine servers in the group).
    </p><p>
      Also the memory and CPU footprint are larger, because more complex
      work is done for the server synchronization part and for the group
      messaging.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-deploy-across-wide-area-network"></a>Can I deploy Group Replication across wide-area networks?</h3>

</div>

</div>

</div>
<p>
      Yes, but the network connection between each member
      <span class="emphasis"><em>must</em></span> be reliable and have suitable
      perfomance. Low latency, high bandwidth network connections are a
      requirement for optimal performance.
    </p><p>
      If network bandwidth alone is an issue, then
      <a class="xref" href="group-replication.html#group-replication-message-compression" title="17.9.7.2 Message Compression">Section 17.9.7.2, “Message Compression”</a> can be
      used to lower the bandwidth required. However, if the network
      drops packets, leading to re-transmissions and higher end-to-end
      latency, throughput and latency are both negatively affected.
</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Warning
</div>
<p>
        When the network round-trip time (RTT) between any group members
        is 5 seconds or more you could encounter problems as the
        built-in failure detection mechanism could be incorrectly
        triggered.
</p>
</div>

</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-automatically-rejoin-temporary-problems"></a>Do members automatically rejoin a group in case of temporary
connectivity problems?</h3>
</div>
</div>
</div>
<p>
      This depends on the reason for the connectivity problem. If the
      connectivity problem is transient and the reconnection is quick
      enough that the failure detector is not aware of it, then the
      server may not be removed from the group. If it is a
      "long" connectivity problem, then the failure detector
      eventually suspects a problem and the server is removed from the
      group.
    </p><p>
      Once a server is removed from the group, you need to join it back
      again. In other words, after a server is removed explicitly from
      the group you need to rejoin it manually (or have a script doing
      it automatically).
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-member-excluded"></a>When is a member excluded from a group?</h3>

</div>

</div>

</div>
<p>
      If the member becomes silent, the other members remove it from the
      group configuration. In practice this may happen when the member
      has crashed or there is a network disconnection.
    </p><p>
      The failure is detected after a given timeout elapses for a given
      member and a new configuration without the silent member in it is
      created.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-node-lag"></a>What happens when one node is significantly lagging behind?</h3>

</div>

</div>

</div>
<p>
      There is no method for defining policies for when to expel members
      automatically from the group. You need to find out why a member is
      lagging behind and fix that or remove the member from the group.
      Otherwise, if the server is so slow that it triggers the flow
      control, then the entire group slows down as well. The flow
      control can be configured according to the your needs.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-member-responsible-reconfiguration"></a>Upon suspicion of a problem in the group, is there a special member
responsible for triggering a reconfiguration?</h3>
</div>
</div>
</div>
<p>
      No, there is no special member in the group in charge of
      triggering a reconfiguration.
    </p><p>
      Any member can suspect that there is a problem. All members need
      to (automatically) agree that a given member has failed. One
      member is in charge of expelling it from the group, by triggering
      a reconfiguration. Which member is responsible for expelling the
      member is not something you can control or set.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-provide-sharding"></a>Can I use Group Replication for sharding?</h3>

</div>

</div>

</div>
<p>
      Group Replication is designed to provide highly available replica
      sets; data and writes are duplicated on each member in the group.
      For scaling beyond what a single system can provide, you need an
      orchestration and sharding framework built around a number of
      Group Replication sets, where each replica set maintains and
      manages a given shard or partition of your total dataset. This
      type of setup, often called a <span class="quote">“<span class="quote">sharded cluster</span>”</span>,
      allows you to scale reads and writes linearly and without limit.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-using-selinux"></a>How do I use Group Replication with SELinux?</h3>

</div>

</div>

</div>
<p>
      If SELinux is enabled, which you can verify using
      <span class="command"><strong>sestatus -v</strong></span>, then you need to enable the use of
      the Group Replication communication port, configured by
      <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>,
      for <a class="link" href="programs.html#mysqld" title="4.3.1 mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> so that it can bind to it and listen
      there. To see which ports MySQL is currently allowed to use, issue
      <span class="command"><strong>semanage port -l | grep mysqld</strong></span>. Assuming the
      port configured is 33061, add the necessary port to those
      permitted by SELinux by issuing <span class="command"><strong>semanage port -a -t
      mysqld_port_t -p tcp 33061</strong></span>.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-using-iptables"></a>How do I use Group Replication with iptables?</h3>

</div>

</div>

</div>
<p>
      If <span class="command"><strong>iptables</strong></span> is enabled, then you need to open
      up the Group Replication port for communication between the
      machines. To see the current rules in place on each machine, issue
      <span class="command"><strong>iptables -L</strong></span>. Assuming the port configured is
      33061, enable communication over the necessary port by issuing
      <span class="command"><strong>iptables -A INPUT -p tcp --dport 33061 -j
      ACCEPT</strong></span>.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-recover-relay-log"></a>How do I recover the relay log for a replication channel used by a group
member?</h3>
</div>
</div>
</div>
<p>
      The replication channels used by Group Replication behave in the
      same way as replication channels used in master to slave
      replication, and as such rely on the relay log. In the event of a
      change of the <a class="link" href="replication.html#sysvar_relay_log"><code class="literal">relay_log</code></a> variable,
      or when the option is not set and the host name changes, there is
      a chance of errors. See <a class="xref" href="replication.html#slave-logs-relaylog" title="16.2.4.1 The Slave Relay Log">Section 16.2.4.1, “The Slave Relay Log”</a> for
      a recovery procedure in this situation. Alternatively, another way
      of fixing the issue specifically in Group Replication is to issue
      a <a class="link" href="sql-syntax.html#stop-group-replication" title="13.4.3.2 STOP GROUP_REPLICATION Syntax"><code class="literal">STOP GROUP_REPLICATION</code></a> statement
      and then a <a class="link" href="sql-syntax.html#start-group-replication" title="13.4.3.1 START GROUP_REPLICATION Syntax"><code class="literal">START GROUP_REPLICATION</code></a>
      statement to restart the instance. The Group Replication plugin
      creates the <code class="literal">group_replication_applier</code> channel
      again.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-two-bind-addresses"></a>Why does Group Replication use two bind addresses?</h3>

</div>

</div>

</div>
<p>
      Group Replication uses two bind addresses in order to split
      network traffic between the SQL address, used by clients to
      communicate with the member, and the
      <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address</code></a>,
      used internally by the group members to communicate. For example,
      assume a server with two network interfaces assigned to the
      network addresses <code class="literal">203.0.113.1</code> and
      <code class="literal">198.51.100.179</code>. In such a situation you could
      use <code class="literal">203.0.113.1:33061</code> for the internal group
      network address by setting
      <a class="link" href="group-replication.html#sysvar_group_replication_local_address"><code class="literal">group_replication_local_address=203.0.113.1:33061</code></a>.
      Then you could use <code class="literal">198.51.100.179</code> for
      <a class="link" href="server-administration.html#sysvar_hostname"><code class="literal">hostname</code></a> and
      <code class="literal">3306</code> for the
      <a class="link" href="server-administration.html#sysvar_port"><code class="literal">port</code></a>. Client SQL applications
      would then connect to the member at
      <code class="literal">198.51.100.179:3306</code>. This enables you to
      configure different rules on the different networks. Similarly,
      the internal group communication can be separated from the network
      connection used for client applications, for increased security.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-hostnames"></a>How does Group Replication use network addresses and hostnames?</h3>

</div>

</div>

</div>
<p>
      Group Replication uses network connections between members and
      therefore its functionality is directly impacted by how you
      configure hostnames and ports. For example, the Group Replication
      recovery procedure is based on asynchronous replication which uses
      the server's hostname and port. When a member joins a group it
      receives the group membership information, using the network
      address information that is listed at
      <a class="link" href="performance-schema.html#replication-group-members-table" title="25.12.11.7 The replication_group_members Table"><code class="literal">performance_schema.replication_group_members</code></a>.
      One of the members listed in that table is selected as the donor
      of the missing data from the group to the new member.
    </p><p>
      This means that any value you configure using a hostname, such as
      the SQL network address or the group seeds address, must be a
      fully qualified name and resolvable by each member of the group.
      You can ensure this for example through DNS, or correctly
      configured <code class="filename">/etc/hosts</code> files, or other local
      processes. If a you want to configure the
      <code class="literal">MEMBER_HOST</code> value on a server, specify it using
      the <a class="link" href="replication.html#sysvar_report_host"><code class="option">--report-host</code></a> option on the
      server before joining it to the group.
</p>
<div class="important" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Important
</div>
<p>
        The assigned value is used directly and is not affected by the
        <a class="link" href="server-administration.html#option_mysqld_skip-name-resolve"><code class="option">--skip-name-resolve</code></a> option.
</p>
</div>
<p>
      To configure <code class="literal">MEMBER_PORT</code> on a server, specify
      it using the <a class="link" href="replication.html#sysvar_report_port"><code class="option">--report-port</code></a> option.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-auto-increment-increment"></a>Why did the auto increment setting on the server change?</h3>

</div>

</div>

</div>
<p>
      When Group Replication is started on a server, the value of
      <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> is
      changed to the value of
      <a class="link" href="group-replication.html#sysvar_group_replication_auto_increment_increment"><code class="literal">group_replication_auto_increment_increment</code></a>,
      which defaults to 7, and the value of
      <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a> is changed
      to the server ID. The changes are reverted when Group Replication
      is stopped. These settings avoid the selection of duplicate
      auto-increment values for writes on group members, which causes
      rollback of transactions. The default auto increment value of 7
      for Group Replication represents a balance between the number of
      usable values and the permitted maximum size of a replication
      group (9 members).
    </p><p>
      The changes are only made and reverted if
      <a class="link" href="replication.html#sysvar_auto_increment_increment"><code class="literal">auto_increment_increment</code></a> and
      <a class="link" href="replication.html#sysvar_auto_increment_offset"><code class="literal">auto_increment_offset</code></a> each have
      their default value of 1. If their values have already been
      modified from the default, Group Replication does not alter them.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h3 class="title"><a name="group-replication-how-to-find-primary"></a>How do I find the primary?</h3>

</div>

</div>

</div>
<p>
      If the group is operating in single-primary mode, it can be useful
      to find out which member is the primary. See
      <a class="xref" href="group-replication.html#group-replication-find-primary" title="17.4.1.3 Finding the Primary">Section 17.4.1.3, “Finding the Primary”</a>
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="group-replication-technical-details"></a>17.9 Group Replication Technical Details</h2>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-plugin-architecture">17.9.1 Group Replication Plugin Architecture</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-the-group">17.9.2 The Group</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-data-manipulation-statements">17.9.3 Data Manipulation Statements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-data-definition-statements">17.9.4 Data Definition Statements</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery">17.9.5 Distributed Recovery</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-observability">17.9.6 Observability</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-performance">17.9.7 Group Replication Performance</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572001056784"></a><p>
    This section provides more technical details about MySQL Group
    Replication.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-plugin-architecture"></a>17.9.1 Group Replication Plugin Architecture</h3>
</div>
</div>
</div>
<a class="indexterm" name="idm140572001053680"></a><a class="indexterm" name="idm140572001052192"></a><a class="indexterm" name="idm140572001050688"></a><p>
      MySQL Group Replication is a MySQL plugin and it builds on the
      existing MySQL replication infrastructure, taking advantage of
      features such as the binary log, row-based logging, and global
      transaction identifiers. It integrates with current MySQL
      frameworks, such as the performance schema or plugin and service
      infrastructures. The following figure presents a block diagram
      depicting the overall architecture of MySQL Group Replication.
</p>
<div class="figure">
<a name="idm140572001048320"></a><p class="title"><b>Figure 17.9 Group Replication Plugin Block Diagram</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-plugin-blocks.png" width="455" height="393" alt="The text following the figure describes the content of the diagram.">
</div>

</div>

</div>
<br class="figure-break"><p>
      The MySQL Group Replication plugin includes a set of APIs for
      capture, apply, and lifecycle, which control how the plugin
      interacts with MySQL Server. There are interfaces to make
      information flow from the server to the plugin and vice versa.
      These interfaces isolate the MySQL Server core from the Group
      Replication plugin, and are mostly hooks placed in the transaction
      execution pipeline. In one direction, from server to the plugin,
      there are notifications for events such as the server starting,
      the server recovering, the server being ready to accept
      connections, and the server being about to commit a transaction.
      In the other direction, the plugin instructs the server to perform
      actions such as committing or aborting ongoing transactions, or
      queuing transactions in the relay log.
    </p><p>
      The next layer of the Group Replication plugin architecture is a
      set of components that react when a notification is routed to
      them. The capture component is responsible for keeping track of
      context related to transactions that are executing. The applier
      component is responsible for executing remote transactions on the
      database. The recovery component manages distributed recovery, and
      is responsible for getting a server that is joining the group up
      to date by selecting the donor, orchestrating the catch up
      procedure and reacting to donor failures.
    </p><p>
      Continuing down the stack, the replication protocol module
      contains the specific logic of the replication protocol. It
      handles conflict detection, and receives and propagates
      transactions to the group.
    </p><p>
      The final two layers of the Group Replication plugin architecture
      are the Group Communication System (GCS) API, and an
      implementation of a Paxos-based group communication engine (XCom).
      The GCS API is a high level API that abstracts the properties
      required to build a replicated state machine (see
      <a class="xref" href="group-replication.html#group-replication-background" title="17.1 Group Replication Background">Section 17.1, “Group Replication Background”</a>). It therefore
      decouples the implementation of the messaging layer from the
      remaining upper layers of the plugin. The group communication
      engine handles communications with the members of the replication
      group.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-the-group"></a>17.9.2 The Group</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572001035696"></a><p>
      In MySQL Group Replication, a set of servers forms a replication
      group. A group has a name, which takes the form of a UUID. The
      group is dynamic and servers can leave (either voluntarily or
      involuntarily) and join it at any time. The group adjusts itself
      whenever servers join or leave.
    </p><p>
      If a server joins the group, it automatically brings itself up to
      date by fetching the missing state from an existing server. This
      state is transferred by means of Asynchronous MySQL replication.
      If a server leaves the group, for instance it was taken down for
      maintenance, the remaining servers notice that it has left and
      reconfigure the group automatically. The group membership service
      described at <a class="xref" href="group-replication.html#group-replication-group-membership" title="17.1.3.1 Group Membership">Section 17.1.3.1, “Group Membership”</a>
      powers all of this.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-data-manipulation-statements"></a>17.9.3 Data Manipulation Statements</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572001030480"></a><p>
      As there are no primary servers (masters) for any particular data
      set, every server in the group is allowed to execute transactions
      at any time, even transactions that change state (RW
      transactions).
    </p><p>
      Any server may execute a transaction without any <span class="emphasis"><em>a
      priori</em></span>

      

      coordination. But, at commit time, it coordinates with the rest of
      the servers in the group to reach a decision on the fate of that
      transaction. This coordination serves two purposes: (i) check
      whether the transaction should commit or not; (ii) and propagate
      the changes so that other servers can apply the transaction as
      well.
    </p><p>
      As a transaction is sent through an atomic broadcast, either all
      servers in the group receive the transaction or none do. If they
      receive it, then they all receive it in the same order with
      respect to other transactions that were sent before. Conflict
      detection is carried out by inspecting and comparing write sets of
      transactions. Thus, they are detected at the row level. Conflict
      resolution follows the first committer wins rule. If t1 and t2
      execute concurrently at different sites, because t2 is ordered
      before t1, and both changed the same row, then t2 wins the
      conflict and t1 aborts. In other words, t1 was trying to change
      data that had been rendered stale by t2.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
        If two transactions are bound to conflict more often than not,
        then it is a good practice to start them on the same server.
        They then have a chance to synchronize on the local lock manager
        instead of aborting later in the replication protocol.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-data-definition-statements"></a>17.9.4 Data Definition Statements</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572001022864"></a><p>
      In a Group Replication topology, care needs to be taken when
      executing data definition statements also commonly known as data
      definition language (DDL). Given that MySQL does not support
      atomic or transactional DDL, one cannot optimistically execute DDL
      statements and later roll back if needs be. Consequently, the lack
      of atomicity does not fit directly into the optimistic replication
      paradigm that Group Replication is based on.
    </p><p>
      Therefore, more care needs to be taken when replicating data
      definition statements. Schema changes and changes to the data that
      the object contains need to be handled through the same server
      while the schema operation has not yet completed and replicated
      everywhere. Failure to do so can result in data inconsistency.
</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Note
</div>
<p>
        If the group is deployed in single-primary mode, then this is
        not a problem, because all changes are performed through the
        same server, the primary.
</p>
</div>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<div class="admon-title">
Warning
</div>
<p>
        MySQL DDL execution is not atomic or transactional. The server
        executes and commits without securing group agreement first. As
        such, you must route DDL and DML for the same object through the
        same server, while the DDL is executing and has not replicated
        everywhere yet.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-distributed-recovery"></a>17.9.5 Distributed Recovery</h3>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-distributed-recovery-basics">17.9.5.1 Distributed Recovery Basics</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-recovering-from-a-point-in-time">17.9.5.2 Recovering From a Point-in-time</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-view-changes">17.9.5.3 View Changes</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-usage-advice-and-limitations-of-distributed-recovery">17.9.5.4 Usage Advice and Limitations of Distributed Recovery</a></span></dt></dl>
</div>
<a class="indexterm" name="idm140572001016064"></a><p>
      This section describes the process through which a member joining
      a group catches up with the remaining servers in the group, called
      distributed recovery. Distributed recovery can be summarized as
      the process through which a server gets missing transactions from
      the group so that it can then join the group having processed the
      same set of transactions as the other group members.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-distributed-recovery-basics"></a>17.9.5.1 Distributed Recovery Basics</h4>
</div>
</div>
</div>
<a class="indexterm" name="idm140572001012512"></a><p>
        Whenever a member joins a replication group, it connects to an
        existing member to carry out state transfer. The server joining
        the group transfers all the transactions that took place in the
        group before it joined, which are provided by the existing
        member (called the <span class="emphasis"><em>donor</em></span>). Next, the server
        joining the group applies the transactions that took place in
        the group while this state transfer was in progress. When the
        server joining the group has caught up with the remaining
        servers in the group, it begins to participate normally in the
        group. This process is called distributed recovery.
</p>
<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h5 class="title"><a name="group-replication-phase-1"></a>Phase 1</h5>
</div>
</div>
</div>
<p>
          In the first phase, the server joining the group selects one
          of the online servers on the group to be the
          <span class="emphasis"><em>donor</em></span> of the state that it is missing.
          The donor is responsible for providing the server joining the
          group all the data it is missing up to the moment it has
          joined the group. This is achieved by relying on a standard
          asynchronous replication channel, established between the
          donor and the server joining the group, see
          <a class="xref" href="replication.html#replication-channels" title="16.2.3 Replication Channels">Section 16.2.3, “Replication Channels”</a>. Through this
          replication channel, the donor's binary logs are replicated
          until the point that the view change happened when the server
          joining the group became part of the group. The server joining
          the group applies the donor's binary logs as it receives them.
        </p><p>
          While the binary log is being replicated, the server joining
          the group also caches every transaction that is exchanged
          within the group. In other words it is listening for
          transactions that are happening after it joined the group and
          while it is applying the missing state from the donor. When
          the first phase ends and the replication channel to the donor
          is closed, the server joining the group then starts phase two:
          the catch up.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h5 class="title"><a name="group-replication-phase-2"></a>Phase 2</h5>

</div>

</div>

</div>
<p>
          In this phase, the server joining the group proceeds to the
          execution of the cached transactions. When the number of
          transactions queued for execution finally reaches zero, the
          member is declared online.
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<div class="simple">
<h5 class="title"><a name="group-replication-resilience"></a>Resilience</h5>

</div>

</div>

</div>
<p>
          The recovery procedure withstands donor failures while the
          server joining the group is fetching binary logs from it. In
          such cases, whenever a donor fails during phase 1, the server
          joining the group fails over to a new donor and resumes from
          that one. When that happens the server joining the group
          closes the connection to the failed server joining the group
          explicitly and opens a connection to a new donor. This happens
          automatically.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-recovering-from-a-point-in-time"></a>17.9.5.2 Recovering From a Point-in-time</h4>

</div>

</div>

</div>
<a class="indexterm" name="idm140572000999632"></a><p>
        To synchronize the server joining the group with the donor up to
        a specific point in time, the server joining the group and donor
        make use of the MySQL Global Transaction Identifiers (GTIDs)
        mechanism. See <a class="xref" href="replication.html#replication-gtids" title="16.1.3 Replication with Global Transaction Identifiers">Section 16.1.3, “Replication with Global Transaction Identifiers”</a>. However,
        GTIDS only provide a means to realize which transactions the
        server joining the group is missing, they do not help marking a
        specific point in time to which the server joining the group
        must catch up, nor do they help conveying certification
        information. This is the job of binary log view markers, which
        mark view changes in the binary log stream, and also contain
        additional metadata information, provisioning the server joining
        the group with missing certification related data.
</p>
<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h5 class="title"><a name="group-replication-view-and-view-changes"></a>View and View Changes</h5>
</div>
</div>
</div>
<p>
          To explain the concept of view change markers, it is important
          to understand what a view and a view change are.
        </p><p>
          A <span class="emphasis"><em>view</em></span> corresponds to a group of members
          participating actively in the current configuration, in other
          words at a specific point in time. They are correct and online
          in the system.
        </p><p>
          A <span class="emphasis"><em>view change</em></span> occurs when a modification
          to the group configuration happens, such as a member joining
          or leaving. Any group membership change results in an
          independent view change communicated to all members at the
          same logical point in time.
        </p><p>
          A <span class="emphasis"><em>view identifier</em></span> uniquely identifies a
          view. It is generated whenever a view change happens
        </p><p>
          At the group communication layer, view changes with their
          associated view ids are then boundaries between the data
          exchanged before and after a member joins. This concept is
          implemented through a new binary log event: the"view
          change log event". The view id thus becomes a marker as
          well for transactions transmitted before and after changes
          happen in the group membership.
        </p><p>
          The view identifier itself is built from two parts:
          <span class="emphasis"><em>(i)</em></span> one that is randomly generated and
          <span class="emphasis"><em>(ii)</em></span> a monotonically increasing integer.
          The first part is generated when the group is created, and
          remains unchanged while there is at least one member in the
          group. The second part is incremented every time a view change
          happens.
        </p><p>
          The reason for this heterogeneous pair that makes up the view
          id is the need to unambiguously mark group changes whenever a
          member joins or leaves but also whenever all members leave the
          group and no information remains of what view the group was
          in. In fact, the sole use of monotonic increasing identifiers
          could lead to the reuse of the same id after full group
          shutdowns, destroying the uniqueness of the binary log data
          markers that recovery depends on. To summarize, the first part
          identifies whenever the group was started from the beginning
          and the incremental part when the group changed from that
          point on.
</p>
</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-view-changes"></a>17.9.5.3 View Changes</h4>

</div>

</div>

</div>
<a class="indexterm" name="idm140572000986448"></a><p>
        This section explains the process which controls how the view
        change identifier is incorporated into a binary log event and
        written to the log, The following steps are taken:
</p>
<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h5 class="title"><a name="group-replication-begin-stable-group"></a>Begin: Stable Group</h5>
</div>
</div>
</div>
<p>
          All servers are online and processing incoming transactions
          from the group. Some servers may be a little behind in terms
          of transactions replicated, but eventually they converge. The
          group acts as one distributed and replicated database.
</p>
<div class="figure">
<a name="idm140572000982544"></a><p class="title"><b>Figure 17.10 Stable Group</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-recovery-1.png" width="534" height="525" alt="Servers S1, S2, and S3 are members of the group. The most recent item in all of their binary logs is transaction T20.">
</div>

</div>

</div>
<br class="figure-break">
</div>

<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h5 class="title"><a name="group-replication-view-change-member-joins"></a>View Change: a Member Joins</h5>

</div>

</div>

</div>
<p>
          Whenever a new member joins the group and therefore a view
          change is performed, every online server queues a view change
          log event for execution. This is queued because before the
          view change, several transactions can be queued on the server
          to be applied and as such, these belong to the old view.
          Queuing the view change event after them guarantees a correct
          marking of when this happened.
        </p><p>
          Meanwhile, the server joining the group selects the donor from
          the list of online servers as stated by the membership service
          through the view abstraction. A member joins on view 4 and the
          online members write a View change event to the binary log.
</p>
<div class="figure">
<a name="idm140572000972976"></a><p class="title"><b>Figure 17.11 A Member Joins</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-recovery-2.png" width="654" height="559" alt="Server S4 joins the group and looks for a donor. Servers S1, S2, and S3 each queue the view change entry VC4 for their binary logs. Meanwhile, server S1 is receiving new transaction T21.">
</div>

</div>

</div>
<br class="figure-break">
</div>

<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h5 class="title"><a name="group-replication-state-transfer-catching-up"></a>State Transfer: Catching Up</h5>

</div>

</div>

</div>
<p>
          Once the server joining the group has chosen which server in
          the group is to be the donor, a new asynchronous replication
          connection is established between the two and the state
          transfer begins (phase 1). This interaction with the donor
          continues until the server joining the group's applier
          thread processes the view change log event that corresponds to
          the view change triggered when the server joining the group
          came into the group. In other words, the server joining the
          group replicates from the donor, until it gets to the marker
          with the view identifier which matches the view marker it is
          already in.
</p>
<div class="figure">
<a name="idm140572000963728"></a><p class="title"><b>Figure 17.12 State Transfer: Catching Up</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-recovery-3.png" width="603" height="525" alt="Server S4 has chosen server S2 as the donor. State transfer is executed from server S2 to server S4 until the view change entry VC4 is reached (view_id = VC4). Server S4 uses a temporary applier buffer for state transfer, and its binary log is currently empty.">
</div>

</div>

</div>
<br class="figure-break"><p>
          As view identifiers are transmitted to all members in the
          group at the same logical time, the server joining the group
          knows at which view identifier it should stop replicating.
          This avoids complex GTID set calculations because the view id
          clearly marks which data belongs to each group view.
        </p><p>
          While the server joining the group is replicating from the
          donor, it is also caching incoming transactions from the
          group. Eventually, it stops replicating from the donor and
          switches to applying those that are cached.
</p>
<div class="figure">
<a name="idm140572000955424"></a><p class="title"><b>Figure 17.13 Queued Transactions</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-recovery-4.png" width="644" height="525" alt="State transfer is complete. Server S4 has applied the transactions up to T20 and written them to its binary log. Server S4 has cached transaction T21, which arrived after the view change, in a temporary applier buffer while recovering.">
</div>

</div>

</div>
<br class="figure-break">
</div>

<div class="simplesect">

<div class="titlepage">
<div>

<div class="simple">
<h5 class="title"><a name="group-replication-finish-caught-up"></a>Finish: Caught Up</h5>

</div>

</div>

</div>
<p>
          When the server joining the group recognizes a view change log
          event with the expected view identifier, the connection to the
          donor is terminated and it starts applying the cached
          transactions. An important point to understand is the final
          recovery procedure. Although it acts as a marker in the binary
          log, delimiting view changes, the view change log event also
          plays another role. It conveys the certification information
          as perceived by all servers when the server joining the group
          entered the group, in other words the last view change.
          Without it, the server joining the group would not have the
          necessary information to be able to certify (detect conflicts)
          subsequent transactions.
        </p><p>
          The duration of the catch up (phase 2) is not deterministic,
          because it depends on the workload and the rate of incoming
          transactions to the group. This process is completely online
          and the server joining the group does not block any other
          server in the group while it is catching up. Therefore the
          number of transactions the server joining the group is behind
          when it moves to phase 2 can, for this reason, vary and thus
          increase or decrease according to the workload.
        </p><p>
          When the server joining the group reaches zero queued
          transactions and its stored data is equal to the other
          members, its public state changes to online.
</p>
<div class="figure">
<a name="idm140572000944592"></a><p class="title"><b>Figure 17.14 Instance Online</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-recovery-5.png" width="597" height="525" alt="Server S4 is now an online member of the group. It has applied cached transaction T21, so its binary log shows the same items as the binary logs of the other group members, and it no longer needs the temporary applier buffer. New incoming transaction T22 is now received and applied by all group members.">
</div>

</div>

</div>
<br class="figure-break">
</div>

</div>

<div class="section">

<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-usage-advice-and-limitations-of-distributed-recovery"></a>17.9.5.4 Usage Advice and Limitations of Distributed Recovery</h4>

</div>

</div>

</div>
<a class="indexterm" name="idm140572000936176"></a><p>
        Distributed recovery does have some limitations. It is based on
        classic asynchronous replication and as such it may be slow if
        the server joining the group is not provisioned at all or is
        provisioned with a very old backup image. This means that if the
        data to transfer is too big at phase 1, the server may take a
        very long time to recover. As such, the recommendation is that
        before adding a server to the group, one should provision it
        with a fairly recent snapshot of a server already in the group.
        This minimizes the length of phase 1 and reduces the impact on
        the donor server, since it has to save and transfer less binary
        logs.
</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">

<div class="admon-title">
Warning
</div>
<p>
          It is recommended that a server is provisioned before it is
          added to a group. That way, one minimizes the time spent on
          the recovery step.
</p>
</div>

</div>

</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-observability"></a>17.9.6 Observability</h3>

</div>

</div>

</div>
<a class="indexterm" name="idm140572000931136"></a><p>
      There is a lot of automation built into the Group Replication
      plugin. Nonetheless, you might sometimes need to understand what
      is happening behind the scenes. This is where the instrumentation
      of Group Replication and Performance Schema becomes important. The
      entire state of the system (including the view, conflict
      statistics and service states) can be queried through
      performance_schema tables. The distributed nature of the
      replication protocol and the fact that server instances agree and
      thus synchronize on transactions and metadata makes it simpler to
      inspect the state of the group. For example, you can connect to a
      single server in the group and obtain both local and global
      information by issuing select statements on the Group Replication
      related Performance Schema tables. For more information, see
      <a class="xref" href="group-replication.html#group-replication-monitoring" title="17.3 Monitoring Group Replication">Section 17.3, “Monitoring Group Replication”</a>.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="group-replication-performance"></a>17.9.7 Group Replication Performance</h3>

</div>

</div>

</div>
<div class="toc">
<dl class="toc"><dt><span class="section"><a href="group-replication.html#group-replication-fine-tuning-the-group-communication-thread">17.9.7.1 Fine Tuning the Group Communication Thread</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-message-compression">17.9.7.2 Message Compression</a></span></dt><dt><span class="section"><a href="group-replication.html#group-replication-flow-control">17.9.7.3 Flow Control</a></span></dt></dl>
</div>
<p>
      This section explains how to use the available configuration
      options to gain the best performance from your group.
</p>
<div class="section">

<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-fine-tuning-the-group-communication-thread"></a>17.9.7.1 Fine Tuning the Group Communication Thread</h4>
</div>
</div>
</div>
<p>
        The group communication thread (GCT) runs in a loop while the
        Group Replication plugin is loaded. The GCT receives messages
        from the group and from the plugin, handles quorum and failure
        detection related tasks, sends out some keep alive messages and
        also handles the incoming and outgoing transactions from/to the
        server/group. The GCT waits for incoming messages in a queue.
        When there are no messages, the GCT waits. By configuring this
        wait to be a little longer (doing an active wait) before
        actually going to sleep can prove to be beneficial in some
        cases. This is because the alternative is for the operating
        system to switch out the GCT from the processor and do a context
        switch.
      </p><p>
        To force the GCT do an active wait, use the
        <a class="link" href="group-replication.html#sysvar_group_replication_poll_spin_loops"><code class="literal">group_replication_poll_spin_loops</code></a>
        option, which makes the GCT loop, doing nothing relevant for the
        configured number of loops, before actually polling the queue
        for the next message.
      </p><p>
        For example:
      </p><pre data-lang="sql" class="programlisting">
mysql&gt; SET GLOBAL group_replication_poll_spin_loops= 10000;</pre>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-message-compression"></a>17.9.7.2 Message Compression</h4>

</div>

</div>

</div>
<p>
        When network bandwidth is a bottleneck, message compression can
        provide up to 30-40% throughput improvement at the group
        communication level. This is especially important within the
        context of large groups of servers under load.
</p>
<div class="table">
<a name="idm140572000918224"></a><p class="title"><b>Table 17.5 LZ4 Compression Ratios for Different Binary Log Formats</b></p>
<div class="table-contents">
<table summary="Compares the compression ratio for the ROW and STATEMENT binary log formats with different workloads."><col width="0.59%"><col width="0.18%"><col width="0.24%"><thead><tr>
            <th scope="col"><p>
                Workload
              </p></th>
            <th scope="col"><p>
                Ratio for ROW
              </p></th>
            <th scope="col"><p>
                Ratio for STMT
              </p></th>
          </tr></thead><tbody><tr>
            <td scope="row"><p>
                mysqlslapd
              </p></td>
            <td><p>
                4,5
              </p></td>
            <td><p>
                4,1
              </p></td>
          </tr><tr>
            <td scope="row"><p>
                sysbench
              </p></td>
            <td><p>
                3,4
              </p></td>
            <td><p>
                2,9
              </p></td>
</tr></tbody></table>
</div>

</div>
<br class="table-break"><p>
        The TCP peer-to-peer nature of the interconnections between
        <span class="emphasis"><em>N</em></span> participants on the group makes the
        sender send the same amount of data <span class="emphasis"><em>N</em></span>
        times. Furthermore, binary logs are likely to exhibit a high
        compression ratio (see table above). This makes compression a
        compelling feature for workloads that contain large transaction.
</p>
<div class="figure">
<a name="idm140572000900640"></a><p class="title"><b>Figure 17.15 Compression Support</b></p>
<div class="figure-contents">

<div class="mediaobject">
<img src="images/gr-compress-decompress.png" width="603" height="492" alt="The MySQL Group Replication plugin architecture is shown as described in an earlier topic, with the five layers of the plugin positioned between the MySQL server and the replication group. Compression and decompression are handled by the Group Communication System API, which is the fourth layer of the Group Replication plugin. The group communication engine (the fifth layer of the plugin) and the group members use the compressed transactions with the smaller data size. The MySQL Server core and the three higher layers of the Group Replication plugin (the APIs, the capture, applier, and recovery components, and the replication protocol module) use the original transactions with the larger data size.">
</div>

</div>

</div>
<br class="figure-break"><p>
        Compression happens at the group communication engine level,
        before the data is handed over to the group communication
        thread, so it happens within the context of the mysql user
        session thread. Transaction payloads may be compressed before
        being sent out to the group and decompressed when received.
        Compression is conditional and depends on a configured
        threshold. By default compression is enabled.
      </p><p>
        In addition, there is no requirement that all servers in the
        group have compression enabled to be able to work together. Upon
        receiving a message, the member checks the message envelope to
        verify whether it is compressed or not. If needed, then the
        member decompresses the transaction, before delivering it to the
        upper layer.
      </p><p>
        The compression algorithm used is LZ4. Compression is enabled by
        default with threshold of 1000000 bytes. The compression
        threshold, in bytes, may be set to something larger than
        default. In that case, only transactions that have a payload
        larger than the threshold are compressed. Below is an example of
        how to set a compression threshold.
      </p><pre data-lang="sql" class="programlisting">
STOP GROUP_REPLICATION;
SET GLOBAL group_replication_compression_threshold= 2097152;
START GROUP_REPLICATION;</pre><p>
        This sets the compression threshold to 2MB. If a transaction
        generates a replication message with a payload larger than 2MB,
        for example a binary log transaction entry larger than 2MB, then
        it is compressed. To disable compression set threshold to 0.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="group-replication-flow-control"></a>17.9.7.3 Flow Control</h4>

</div>

</div>

</div>
<p>
        Group Replication ensures that a transaction only commits after
        a majority of the members in a group have received it and agreed
        on the relative order between all transactions that were sent
        concurrently.
      </p><p>
        This approach works well if the total number of writes to the
        group does not exceed the write capacity of any member in the
        group. If it does and some of the members have less write
        throughput than others, particularly less than the writer
        members, those members can start lagging behind of the writers.
      </p><p>
        Having some members lagging behind the group brings some
        problematic consequences, particularly, the reads on such
        members may externalize very old data. Depending on why the
        member is lagging behind, other members in the group may have to
        save more or less replication context to be able to fulfil
        potential data transfer requests from the slow member.
      </p><p>
        There is however a mechanism in the replication protocol to
        avoid having too much distance, in terms of transactions
        applied, between fast and slow members. This is known as the
        flow control mechanism. It tries to address several goals:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
            to keep the members close enough to make buffering and
            de-synchronization between members a small problem;
          </p></li><li class="listitem"><p>
            to adapt quickly to changing conditions like different
            workloads or more writers in the group;
          </p></li><li class="listitem"><p>
            to give each member a fair share of the available write
            capacity;
          </p></li><li class="listitem"><p>
            to not reduce throughput more than strictly necessary to
            avoid wasting resources.
</p></li></ol>
</div>
<p>
        Given the design of Group Replication, the decision whether to
        throttle or not may be decided taking into account two work
        queues: <span class="emphasis"><em>(i)</em></span> the
        <span class="emphasis"><em>certification</em></span> queue;
        <span class="emphasis"><em>(ii)</em></span> and on the binary log
        <span class="emphasis"><em>applier</em></span> queue. Whenever the size of one of
        these queues exceeds the user-defined threshold, the throttling
        mechanism is triggered. Only configure: <span class="emphasis"><em>(i)</em></span>
        whether to do flow control at the certifier or at the applier
        level, or both; and <span class="emphasis"><em>(ii)</em></span> what is the
        threshold for each queue.
      </p><p>
        The flow control depends on two basic mechanisms:
</p>
<div class="orderedlist">
<ol class="orderedlist" type="1"><li class="listitem"><p>
            the monitoring of members to collect some statistics on
            throughput and queue sizes of all group members to make
            educated guesses on what is the maximum write pressure each
            member should be subjected to;
          </p></li><li class="listitem"><p>
            the throttling of members that are trying to write beyond
            their fair-share of the available capacity at each moment in
            time.
</p></li></ol>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h5 class="title"><a name="group-replication-probes-and-statistics"></a>17.9.7.3.1 Probes and Statistics</h5>

</div>

</div>

</div>
<p>
          The monitoring mechanism works by having each member deploying
          a set of probes to collect information about its work queues
          and throughput. It then propagates that information to the
          group periodically to share that data with the other members.
        </p><p>
          Such probes are scattered throughout the plugin stack and
          allow one to establish metrics, such as:
</p>
<div class="itemizedlist">
<ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
              the certifier queue size;
            </p></li><li class="listitem"><p>
              the replication applier queue size;
            </p></li><li class="listitem"><p>
              the total number of transactions certified;
            </p></li><li class="listitem"><p>
              the total number of remote transactions applied in the
              member;
            </p></li><li class="listitem"><p>
              the total number of local transactions.
</p></li></ul>
</div>
<p>
          Once a member receives a message with statistics from another
          member, it calculates additional metrics regarding how many
          transactions were certified, applied and locally executed in
          the last monitoring period.
        </p><p>
          Monitoring data is shared with others in the group
          periodically. The monitoring period must be high enough to
          allow the other members to decide on the current write
          requests, but low enough that it has minimal impact on group
          bandwidth. The information is shared every second, and this
          period is sufficient to address both concerns.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<div>
<h5 class="title"><a name="group-replication-throttling"></a>17.9.7.3.2 Group Replication Throttling</h5>

</div>

</div>

</div>
<p>
          Based on the metrics gathered across all servers in the group,
          a throttling mechanism kicks in and decides whether to limit
          the rate a member is able to execute/commit new transactions.
        </p><p>
          Therefore, metrics acquired from all members are the basis for
          calculating the capacity of each member: if a member has a
          large queue (for certification or the applier thread), then
          the capacity to execute new transactions should be close to
          ones certified or applied in the last period.
        </p><p>
          The lowest capacity of all the members in the group determines
          the real capacity of the group, while the number of local
          transactions determines how many members are writing to it,
          and, consequently, how many members should that available
          capacity be shared with.
        </p><p>
          This means that every member has an established write quota
          based on the available capacity, in other words a number of
          transactions it can safely issue for the next period. The
          writer-quota will be enforced by the throttling mechanism if
          the queue size of the certifier or the binary log applier
          exceeds a user-defined threshold.

          
        </p><p>
          The quota is reduced by the number of transactions that were
          delayed in the last period, and then also further reduced by
          10% to allow the queue that triggered the problem to reduce
          its size. In order to avoid large jumps in throughput once the
          queue size goes beyond the threshold, the throughput is only
          allowed to grow by the same 10% per period after that.
        </p><p>
          The current throttling mechanism does not penalize
          transactions below quota, but delays finishing those
          transactions that exceed it until the end of the monitoring
          period. As a consequence, if the quota is very small for the
          write requests issued some transactions may have latencies
          close to the monitoring period.
</p>
</div>

</div>

</div>

</div>

</div>
<div class="copyright-footer">

</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left"><a accesskey="p" href="replication.html">Prev</a></td>
<td width="20%" align="center"><a accesskey="u" href="">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="mysql-shell-userguide.html">Next</a></td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Chapter 16 Replication</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top">Chapter 18 MySQL Shell</td>
</tr>
</table>
</div>
</body>
</html>
